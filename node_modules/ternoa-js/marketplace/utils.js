"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatMarketplaceCollectionList = exports.formatMarketplaceOffchainData = exports.formatMarketplaceAccountList = exports.formatMarketplaceFee = exports.convertMarketplaceFee = void 0;
var utils_1 = require("../helpers/utils");
var blockchain_1 = require("../blockchain");
var constants_1 = require("../constants");
var enum_1 = require("./enum");
/**
 * @name convertMarketplaceFee
 * @summary         Checks the type fee and format it accordingly. Numbers are formatted into BN. Percentages are formatted in Permill.
 * @param fee       The fee to format : It can only be an CommissionFeeType or ListingFeeType.
 * @returns         The formatted fee.
 */
var convertMarketplaceFee = function (fee) { return __awaiter(void 0, void 0, void 0, function () {
    var flatFee, percentageFee;
    return __generator(this, function (_a) {
        if (typeof fee === "object") {
            if (typeof fee.set.flat === "number") {
                flatFee = (0, blockchain_1.numberToBalance)(fee.set.flat);
                fee.set.flat = flatFee;
            }
            if (fee.set.percentage) {
                percentageFee = (0, utils_1.formatPermill)(fee.set.percentage);
                fee.set.percentage = percentageFee;
            }
        }
        return [2 /*return*/, fee];
    });
}); };
exports.convertMarketplaceFee = convertMarketplaceFee;
/**
 * @name formatMarketplaceFee
 * @summary Returns an object representing either the marketplace commission or listing fee in either in Flat or Percentage format.
 *
 * @param action - The type of Action. Can be either "Noop" (No Operation: to keep it as it is), "Remove" or "set".
 * @param feeType - The type of fee. Can be either "percentage" or "flat",
 * @param value - The value of the fee. If type is 'Percentage' value refers to a decimal number in range [0, 100]. If type is 'Flat' value refers to a balance amount in a number. Default is 0.
 *
 * @returns An object representing either the marketplace commission or listing fee.
 */
var formatMarketplaceFee = function (action, feeType, value) {
    var _a, _b, _c, _d;
    if (action !== "Noop" && action !== "Remove" && action !== "set")
        throw new Error("INCORRECT_ACTION: action has to be either 'Noop', 'Remove', 'set'.");
    if (feeType && feeType !== "percentage" && feeType !== "flat")
        throw new Error("INCORRECT_FEE_TYPE: feeType has to be either 'percentage' or 'flat'.");
    switch (action) {
        case "Noop":
            return enum_1.MarketplaceConfigAction.Noop;
        case "Remove":
            return enum_1.MarketplaceConfigAction.Remove;
        case "set": {
            if (value === undefined || feeType === undefined)
                throw new Error("".concat(constants_1.Errors.VALUE_MUST_BE_DEFINED));
            if (feeType && feeType === "percentage") {
                return _a = {},
                    _a[enum_1.MarketplaceConfigAction.Set] = (_b = {}, _b[enum_1.MarketplaceConfigFeeType.Percentage] = (0, utils_1.formatPermill)(value), _b),
                    _a;
            }
            else {
                return _c = {},
                    _c[enum_1.MarketplaceConfigAction.Set] = (_d = {}, _d[enum_1.MarketplaceConfigFeeType.Flat] = (0, blockchain_1.numberToBalance)(value), _d),
                    _c;
            }
        }
        default:
            return enum_1.MarketplaceConfigAction.Noop;
    }
};
exports.formatMarketplaceFee = formatMarketplaceFee;
/**
 * @name formatMarketplaceAccountList
 * @summary Returns an object representing a list of accounts : if the marketplace kind is private, it allows these accounts to sell NFT. If the marketplace kind is public, it bans these accounts from selling NFT.
 *
 * @param action - The type of Action. Can be either "Noop" (No Operation: to keep it as it is), "Remove" or "set".
 * @param value - An array of addresses (string) to add to the list.
 *
 * @returns An object representing either the whitelisted or banned accounts.
 */
var formatMarketplaceAccountList = function (action, value) {
    var _a;
    if (action !== "Noop" && action !== "Remove" && action !== "set")
        throw new Error("INCORRECT_ACTION: action has to be either 'Noop', 'Remove', 'set'.");
    switch (action) {
        case "Noop":
            return enum_1.MarketplaceConfigAction.Noop;
        case "Remove":
            return enum_1.MarketplaceConfigAction.Remove;
        case "set": {
            if (value === undefined)
                throw new Error("".concat(constants_1.Errors.VALUE_MUST_BE_DEFINED));
            return _a = {},
                _a[enum_1.MarketplaceConfigAction.Set] = value,
                _a;
        }
        default:
            return enum_1.MarketplaceConfigAction.Noop;
    }
};
exports.formatMarketplaceAccountList = formatMarketplaceAccountList;
/**
 * @name formatMarketplaceOffchainData
 * @summary Returns the off-chain related marketplace metadata. Can be an IPFS Hash, an URL or plain text.
 *
 * @param action - The type of Action. Can be either "Noop" (No Operation: to keep it as it is), "Remove" or "set".
 * @param value - The marketplkace offchain metadata : a string
 *
 * @returns An object representing either the marketplace offchain metadata.
 */
var formatMarketplaceOffchainData = function (action, value) {
    var _a;
    if (action !== "Noop" && action !== "Remove" && action !== "set")
        throw new Error("INCORRECT_ACTION: action has to be either 'Noop', 'Remove', 'set'.");
    switch (action) {
        case "Noop":
            return enum_1.MarketplaceConfigAction.Noop;
        case "Remove":
            return enum_1.MarketplaceConfigAction.Remove;
        case "set": {
            if (value === undefined)
                throw new Error("".concat(constants_1.Errors.VALUE_MUST_BE_DEFINED));
            return _a = {},
                _a[enum_1.MarketplaceConfigAction.Set] = value,
                _a;
        }
        default:
            return enum_1.MarketplaceConfigAction.Noop;
    }
};
exports.formatMarketplaceOffchainData = formatMarketplaceOffchainData;
/**
 * @name formatMarketplaceCollectionList
 * @summary Returns an object representing a list of collection of NFT : if the marketplace kind is private, it allows these collection to be listed. If the marketplace kind is public, it bans these collection of NFT from listing.
 *
 * @param action - The type of Action. Can be either "Noop" (No Operation: to keep it as it is), "Remove" or "set".
 * @param value - An array of Collection id (number) to add to the list.
 *
 * @returns An object representing either the whitelisted or banned collection Id.
 */
var formatMarketplaceCollectionList = function (action, value) {
    var _a;
    if (action !== "Noop" && action !== "Remove" && action !== "set")
        throw new Error("INCORRECT_ACTION: action has to be either 'Noop', 'Remove', 'set'.");
    switch (action) {
        case "Noop":
            return enum_1.MarketplaceConfigAction.Noop;
        case "Remove":
            return enum_1.MarketplaceConfigAction.Remove;
        case "set": {
            if (value === undefined)
                throw new Error("".concat(constants_1.Errors.VALUE_MUST_BE_DEFINED));
            return _a = {},
                _a[enum_1.MarketplaceConfigAction.Set] = value,
                _a;
        }
        default:
            return enum_1.MarketplaceConfigAction.Noop;
    }
};
exports.formatMarketplaceCollectionList = formatMarketplaceCollectionList;
