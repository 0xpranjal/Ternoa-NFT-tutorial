"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMarketplaceMintFee = exports.setMarketplaceMintFeeTx = exports.buyNft = exports.buyNftTx = exports.unlistNft = exports.unlistNftTx = exports.listNft = exports.listNftTx = exports.setMarketplaceKind = exports.setMarketplaceKindTx = exports.setMarketplaceOwner = exports.setMarketplaceOwnerTx = exports.setMarketplaceConfiguration = exports.setMarketplaceConfigurationTx = exports.createMarketplace = exports.createMarketplaceTx = void 0;
var blockchain_1 = require("../blockchain");
var constants_1 = require("../constants");
var events_1 = require("../events");
var enum_1 = require("./enum");
/**
 * @name createMarketplaceTx
 * @summary               Creates an unsigned unsubmitted Create-Marketplace Transaction Hash.
 * @param kind            Kind of marketplace : It must be public or private.
 * @returns               Unsigned unsubmitted Create-Marketplace Transaction Hash. The Hash is only valid for 5 minutes.
 */
var createMarketplaceTx = function (kind) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.createMarketplace, [kind])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.createMarketplaceTx = createMarketplaceTx;
/**
 * @name createMarketplace
 * @summary               Creates a Marketplace on the chain.
 * @param kind            Kind of marketplace : It must be public or private.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               MarketplaceCreatedEvent Blockchain event.
 */
var createMarketplace = function (kind, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.createMarketplaceTx)(kind)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.MarketplaceCreatedEvent)];
        }
    });
}); };
exports.createMarketplace = createMarketplace;
/**
 * @name setMarketplaceConfigurationTx
 * @summary               Creates an unsigned unsubmitted Set-Marketplace-Configuration Transaction Hash.
 *
 *                        Each of the parameters of the marketplace, need one of the following type: Noop is set by default for each of the parameters.
 *                        - Noop: No Operation, nothing change.
 *                        - Remove: Current datas will be deleted.
 *                        - Set: An object that updates parameter value below.
 *                            - Commission Fee and Listing Fee require a data type (flat or percentage) under format : { [MarketplaceConfigAction.Set]: { setFeeType: number || BN}}
 *                            - AccountList require an array of string: { [MarketplaceConfigAction.Set]: string[]}
 *                            - OffChainData require a string: { [MarketplaceConfigAction.Set]: string}
 *                            - CollectionList require an arry of number: { [MarketplaceConfigAction.Set]: number[]}
 *
 *                        IMPORTANT: In order to avoid any error, we strongly recommand you to construct those fields using the helpers we provide.
 *                        - formatMarketplaceFee() for both commission and listing fee.
 *                        - formatMarketplaceAccountList() for the account list.
 *                        - formatMarketplaceOffchainData() for the offchain data.
 *                        - formatMarketplaceCollectionList() for the collection list.
 *                        - Check {@link https://docs.ternoa.network/for-developers/guides/marketplace/ Ternoa Doc}.
 *
 * @param id              Marketplace Id of the marketplace to update.
 * @param commissionFee   Commission when an NFT is sold on the marketplace : it can be set as flat (in Big Number format) or as percentage (in permill format). Without using formatters, you can use the convertMarketplaceFee() function.
 * @param listingFee      Fee when an NFT is added for sale to marketplace : it can be set as flat (in Big Number format) or as percentage (in permill format). Without using formatters, you can use the convertMarketplaceFee() function.
 * @param accountList     A list of accounts : if the marketplace kind is private, it allows these accounts to sell NFT. If the marketplace kind is public, it bans these accounts from selling NFT.
 * @param offchainData    Off-chain related marketplace metadata. Can be an IPFS Hash, an URL or plain text.
 * @param collectionList  A list of Collection Id: same as accountList, if the marketplace kind is private, the list is a whitelist and if the marketplace is public, the list bans the collection to be listed.
 * @returns               MarketplaceConfigSetEvent Blockchain event.
 */
var setMarketplaceConfigurationTx = function (id, commissionFee, listingFee, accountList, offchainData, collectionList) {
    if (commissionFee === void 0) { commissionFee = enum_1.MarketplaceConfigAction.Noop; }
    if (listingFee === void 0) { listingFee = enum_1.MarketplaceConfigAction.Noop; }
    if (accountList === void 0) { accountList = enum_1.MarketplaceConfigAction.Noop; }
    if (offchainData === void 0) { offchainData = enum_1.MarketplaceConfigAction.Noop; }
    if (collectionList === void 0) { collectionList = enum_1.MarketplaceConfigAction.Noop; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.setMarketplaceConfiguration, [
                        id,
                        commissionFee,
                        listingFee,
                        accountList,
                        offchainData,
                        collectionList,
                    ])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
};
exports.setMarketplaceConfigurationTx = setMarketplaceConfigurationTx;
/**
 * @name setMarketplaceConfiguration
 * @summary               Set or Remove (Noop for No Operation) the marketplace parameters configuration : Commission fee, listing fee, the account list or any offchain datas.
 *
 *                        Each of the parameters of the marketplace, need one of the following type: Noop is set by default for each of the parameters.
 *                        - Noop: No Operation, nothing change.
 *                        - Remove: Current datas will be deleted.
 *                        - Set: An object that updates parameter value below.
 *                            - Commission Fee and Listing Fee require a data type (flat or percentage) under format : { [MarketplaceConfigAction.Set]: { setFeeType: number || BN}}
 *                            - AccountList require an array of string: { [MarketplaceConfigAction.Set]: string[]}
 *                            - OffChainData require a string: { [MarketplaceConfigAction.Set]: string}
 *                            - CollectionList require an arry of number: { [MarketplaceConfigAction.Set]: number[]}
 *
 *                        IMPORTANT: In order to avoid any error, we strongly recommand you to construct those fields using the helpers we provide.
 *                        - formatMarketplaceFee() for both commission and listing fee.
 *                        - formatMarketplaceAccountList() for the account list.
 *                        - formatMarketplaceOffchainData() for the offchain data.
 *                        - formatMarketplaceCollectionList() for the collection list.
 *                        - Check {@link https://docs.ternoa.network/for-developers/guides/marketplace/ Ternoa Doc}.
 *
 * @param id              Marketplace Id of the marketplace to update.
 * @param commissionFee   Commission when an NFT is sold on the marketplace : it can be set as flat (in Big Number format) or as percentage (in permill format). Without using formatters, you can use the convertMarketplaceFee() function.
 * @param listingFee      Fee when an NFT is added for sale to marketplace : it can be set as flat (in Big Number format) or as percentage (in permill format). Without using formatters, you can use the convertMarketplaceFee() function.
 * @param accountList     A list of accounts : if the marketplace kind is private, it allows these accounts to sell NFT. If the marketplace kind is public, it bans these accounts from selling NFT.
 * @param offchainData    Off-chain related marketplace metadata. Can be an IPFS Hash, an URL or plain text.
 * @param collectionList  A list of Collection Id: same as accountList, if the marketplace kind is private, the list is a whitelist and if the marketplace is public, the list bans the collection to be listed.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               MarketplaceConfigSetEvent Blockchain event.
 */
var setMarketplaceConfiguration = function (id, commissionFee, listingFee, accountList, offchainData, collectionList, keyring, waitUntil) {
    if (commissionFee === void 0) { commissionFee = enum_1.MarketplaceConfigAction.Noop; }
    if (listingFee === void 0) { listingFee = enum_1.MarketplaceConfigAction.Noop; }
    if (accountList === void 0) { accountList = enum_1.MarketplaceConfigAction.Noop; }
    if (offchainData === void 0) { offchainData = enum_1.MarketplaceConfigAction.Noop; }
    if (collectionList === void 0) { collectionList = enum_1.MarketplaceConfigAction.Noop; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx, events;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.setMarketplaceConfigurationTx)(id, commissionFee, listingFee, accountList, offchainData, collectionList)];
                case 1:
                    tx = _a.sent();
                    return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
                case 2:
                    events = (_a.sent()).events;
                    return [2 /*return*/, events.findEventOrThrow(events_1.MarketplaceConfigSetEvent)];
            }
        });
    });
};
exports.setMarketplaceConfiguration = setMarketplaceConfiguration;
/**
 * @name setMarketplaceOwnerTx
 * @summary               Creates an unsigned unsubmitted Set-Marketplace-Owner Transaction Hash.
 * @param id              Marketplace Id of the marketplace to be transferred.
 * @param recipient       Adress of the new marketplace owner.
 * @returns               Unsigned unsubmitted Set-Marketplace-Owner Transaction Hash. The Hash is only valid for 5 minutes.
 */
var setMarketplaceOwnerTx = function (id, recipient) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.setMarketplaceOwner, [id, recipient])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.setMarketplaceOwnerTx = setMarketplaceOwnerTx;
/**
 * @name setMarketplaceOwner
 * @summary               Set the new marketplace owner on the chain.
 * @param id              Marketplace Id of the marketplace to be transferred.
 * @param recipient       Address of the new marketplace owner.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               MarketplaceOwnerSetEvent Blockchain event.
 */
var setMarketplaceOwner = function (id, recipient, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.setMarketplaceOwnerTx)(id, recipient)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.MarketplaceOwnerSetEvent)];
        }
    });
}); };
exports.setMarketplaceOwner = setMarketplaceOwner;
/**
 * @name setMarketplaceKindTx
 * @summary               Creates an unsigned unsubmitted Set-Marketplace-Kind Transaction Hash.
 * @param kind            Kind of marketplace : It must be public or private.
 * @returns               Unsigned unsubmitted Set-Marketplace-Kind Transaction Hash. The Hash is only valid for 5 minutes.
 */
var setMarketplaceKindTx = function (id, kind) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.setMarketplaceKind, [id, kind])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.setMarketplaceKindTx = setMarketplaceKindTx;
/**
 * @name setMarketplaceKind
 * @summary               Set the new marketplace kind on the chain.
 * @param kind            Kind of marketplace : It must be public or private.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               MarketplaceKindSetEvent Blockchain event.
 */
var setMarketplaceKind = function (id, kind, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.setMarketplaceKindTx)(id, kind)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.MarketplaceKindSetEvent)];
        }
    });
}); };
exports.setMarketplaceKind = setMarketplaceKind;
/**
 * @name listNftTx
 * @summary               Creates an unsigned unsubmitted List-NFT Transaction Hash.
 * @param nftId           NFT Id of the NFT to be listed for sale.
 * @param marketplaceId   Marketplace Id of the marketplace to list the NFT on.
 * @param price           Price of the NFT.
 * @returns               Unsigned unsubmitted List-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var listNftTx = function (nftId, marketplaceId, price) { return __awaiter(void 0, void 0, void 0, function () {
    var formattedPrice;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                formattedPrice = typeof price === "number" ? (0, blockchain_1.numberToBalance)(price) : price;
                return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.listNft, [nftId, marketplaceId, formattedPrice])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.listNftTx = listNftTx;
/**
 * @name listNft
 * @summary               Lists an NFT on a marketplace.
 * @param nftId           NFT Id of the NFT to be listed for sale.
 * @param marketplaceId   Marketplace Id of the marketplace to list the NFT on.
 * @param price           Price of the NFT.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTListedEvent Blockchain event.
 */
var listNft = function (nftId, marketplaceId, price, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.listNftTx)(nftId, marketplaceId, price)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.NFTListedEvent)];
        }
    });
}); };
exports.listNft = listNft;
/**
 * @name unlistNftTx
 * @summary               Creates an unsigned unsubmitted Unlist-NFT Transaction Hash.
 * @param nftId           NFT Id of the NFT to be unlisted from sale.
 * @returns               Unsigned unsubmitted Unlist-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var unlistNftTx = function (nftId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.unlistNft, [nftId])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.unlistNftTx = unlistNftTx;
/**
 * @name unlistNft
 * @summary               Unlists an NFT from a marketplace.
 * @param nftId           NFT Id of the NFT to be unlisted from sale.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTUnlistedEvent Blockchain event.
 */
var unlistNft = function (nftId, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.unlistNftTx)(nftId)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.NFTUnlistedEvent)];
        }
    });
}); };
exports.unlistNft = unlistNft;
/**
 * @name buyNftTx
 * @summary               Creates an unsigned unsubmitted Buy-NFT Transaction Hash.
 * @param nftId           NFT Id of the NFT for sale.
 * @param nftBuyingPrice  The NFT buying price signed.
 * @returns               Unsigned unsubmitted Buy-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var buyNftTx = function (nftId, nftBuyingPrice) { return __awaiter(void 0, void 0, void 0, function () {
    var formattedNftBuyingPrice;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                formattedNftBuyingPrice = typeof nftBuyingPrice === "number" ? (0, blockchain_1.numberToBalance)(nftBuyingPrice) : nftBuyingPrice;
                return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.buyNft, [nftId, formattedNftBuyingPrice])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.buyNftTx = buyNftTx;
/**
 * @name buyNft
 * @summary               Buys an NFT on a marketplace.
 * @param nftId           NFT Id of the NFT for sale.
 * @param nftBuyingPrice  The NFT buying price signed.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTSoldEvent Blockchain event.
 */
var buyNft = function (nftId, nftBuyingPrice, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.buyNftTx)(nftId, nftBuyingPrice)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.NFTSoldEvent)];
        }
    });
}); };
exports.buyNft = buyNft;
/**
 * @name setMarketplaceMintFeeTx
 * @summary               Creates an unsigned unsubmitted Set-Marketplace-Mint-Fee Transaction Hash.
 * @param fee             Fee to mint a marketplace.
 * @returns               Unsigned unsubmitted Set-Marketplace-Mint-Fee Transaction Hash. The Hash is only valid for 5 minutes.
 */
var setMarketplaceMintFeeTx = function (fee) { return __awaiter(void 0, void 0, void 0, function () {
    var formattedPrice;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                formattedPrice = typeof fee === "number" ? (0, blockchain_1.numberToBalance)(fee) : fee;
                return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.marketplace, constants_1.txActions.setMarketplaceMintFee, [formattedPrice])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.setMarketplaceMintFeeTx = setMarketplaceMintFeeTx;
/**
 * @name setMarketplaceMintFee
 * @summary               Set the new marketplace minting fee on the chain.
 * @param fee             Fee to mint a marketplace.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTSoldEvent Blockchain event.
 */
var setMarketplaceMintFee = function (fee, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.setMarketplaceMintFeeTx)(fee)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.MarketplaceMintFeeSetEvent)];
        }
    });
}); };
exports.setMarketplaceMintFee = setMarketplaceMintFee;
