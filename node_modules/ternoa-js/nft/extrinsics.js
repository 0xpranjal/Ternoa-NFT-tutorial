"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setCollectionOffchaindata = exports.setCollectionOffchaindataTx = exports.burnCollection = exports.burnCollectionTx = exports.closeCollection = exports.closeCollectionTx = exports.limitCollection = exports.limitCollectionTx = exports.createCollection = exports.createCollectionTx = exports.notifyEnclaveKeyUpdate = exports.notifyEnclaveKeyUpdateTx = exports.setCapsuleOffchaindata = exports.setCapsuleOffchaindataTx = exports.createCapsule = exports.createCapsuleTx = exports.convertNftToCapsule = exports.convertNftToCapsuleTx = exports.addNftToCollection = exports.addNftToCollectionTx = exports.transferNft = exports.transferNftTx = exports.setRoyalty = exports.setRoyaltyTx = exports.delegateNft = exports.delegateNftTx = exports.burnNft = exports.burnNftTx = exports.addSecretToNft = exports.addSecretToNftTx = exports.createSecretNft = exports.createSecretNftTx = exports.createNft = exports.createNftTx = void 0;
var blockchain_1 = require("../blockchain");
var constants_1 = require("../constants");
var events_1 = require("../events");
var utils_1 = require("../helpers/utils");
// NFTs
/**
 * @name createNftTx
 * @summary             Creates an unsigned unsubmitted Create-NFT Transaction Hash.
 * @param offchainData  Off-chain related NFT metadata. Can be an IPFS Hash, an URL or plain text.
 * @param royalty       Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId  The collection that this NFT will belong. Optional Parameter.
 * @param isSoulbound   If true makes the NFT untransferable. Default is false.
 * @returns             Unsigned unsubmitted Create-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var createNftTx = function (offchainData, royalty, collectionId, isSoulbound) {
    if (royalty === void 0) { royalty = 0; }
    if (collectionId === void 0) { collectionId = undefined; }
    if (isSoulbound === void 0) { isSoulbound = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var formattedRoyality;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    formattedRoyality = (0, utils_1.formatPermill)(royalty);
                    return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.createNft, [
                            offchainData,
                            formattedRoyality,
                            collectionId,
                            isSoulbound,
                        ])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
};
exports.createNftTx = createNftTx;
/**
 * @name createNft
 * @summary             Creates an NFT on the chain.
 * @param offchainData  Off-chain related NFT metadata. Can be an IPFS Hash, an URL or plain text.
 * @param royalty       Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId  The collection that this NFT will belong. Optional Parameter.
 * @param isSoulbound   If true makes the NFT untransferable. Default is false.
 * @param keyring       Account that will sign the transaction.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns             NFTCreatedEvent Blockchain event.
 */
var createNft = function (offchainData, royalty, collectionId, isSoulbound, keyring, waitUntil) {
    if (royalty === void 0) { royalty = 0; }
    if (collectionId === void 0) { collectionId = undefined; }
    if (isSoulbound === void 0) { isSoulbound = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx, events;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.createNftTx)(offchainData, royalty, collectionId, isSoulbound)];
                case 1:
                    tx = _a.sent();
                    return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
                case 2:
                    events = (_a.sent()).events;
                    return [2 /*return*/, events.findEventOrThrow(events_1.NFTCreatedEvent)];
            }
        });
    });
};
exports.createNft = createNft;
/**
 * @name createSecretNftTx
 * @summary                   Creates an unsigned unsubmitted Create-Secret-NFT Transaction Hash.
 * @param offchainData        Off-chain related NFT preview metadata. Can be an IPFS hash, a URL or plain text.
 * @param secretOffchainData  Off-chain related NFT secret metadata. Can be an IPFS hash, a URL or plain text.
 * @param royalty             Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId        The collection to which the NFT belongs. Optional Parameter.
 * @param isSoulbound         If true, makes the NFT intransferable. Default is false.
 * @returns                   Unsigned unsubmitted Create-Secret-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var createSecretNftTx = function (offchainData, secretOffchainData, royalty, collectionId, isSoulbound) {
    if (royalty === void 0) { royalty = 0; }
    if (collectionId === void 0) { collectionId = undefined; }
    if (isSoulbound === void 0) { isSoulbound = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var formattedRoyality;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    formattedRoyality = (0, utils_1.formatPermill)(royalty);
                    return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.createSecretNft, [
                            offchainData,
                            secretOffchainData,
                            formattedRoyality,
                            collectionId,
                            isSoulbound,
                        ])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
};
exports.createSecretNftTx = createSecretNftTx;
/**
 * @name createSecretNft
 * @summary                   Creates a Secret NFT on chain.
 * @param offchainData        Off-chain related NFT preview metadata. Can be an IPFS hash, a URL or plain text.
 * @param secretOffchainData  Off-chain related NFT secret metadata. Can be an IPFS hash, a URL or plain text.
 * @param royalty             Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId        The collection to which the NFT belongs. Optional Parameter.
 * @param isSoulbound         If true, makes the NFT intransferable. Default is false.
 * @param keyring             Account that will sign the transaction.
 * @param waitUntil           Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns                   Secret NFT data combining the data from NFTCreatedEvent and SecretAddedToNFTEvent.
 */
var createSecretNft = function (offchainData, secretOffchainData, royalty, collectionId, isSoulbound, keyring, waitUntil) {
    if (royalty === void 0) { royalty = 0; }
    if (collectionId === void 0) { collectionId = undefined; }
    if (isSoulbound === void 0) { isSoulbound = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx, events, nftCreatedEvent, secretAddedToNFTEvent;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.createSecretNftTx)(offchainData, secretOffchainData, royalty, collectionId, isSoulbound)];
                case 1:
                    tx = _a.sent();
                    return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
                case 2:
                    events = (_a.sent()).events;
                    nftCreatedEvent = events.findEventOrThrow(events_1.NFTCreatedEvent);
                    secretAddedToNFTEvent = events.findEventOrThrow(events_1.SecretAddedToNFTEvent);
                    return [2 /*return*/, {
                            nftId: nftCreatedEvent.nftId,
                            owner: nftCreatedEvent.owner,
                            creator: nftCreatedEvent.owner,
                            offchainData: nftCreatedEvent.offchainData,
                            secretOffchainData: secretAddedToNFTEvent.offchainData,
                            royalty: nftCreatedEvent.royalty,
                            collectionId: nftCreatedEvent.collectionId,
                            isSoulbound: nftCreatedEvent.isSoulbound,
                        }];
            }
        });
    });
};
exports.createSecretNft = createSecretNft;
/**
 * @name addSecretToNftTx
 * @summary                   Creates an unsigned unsubmitted Add-Secret-NFT Transaction Hash.
 * @param id                  The ID of the NFT.
 * @param secretOffchainData  Off-chain related NFT secret metadata. Can be an IPFS hash, a URL or plain text.
 * @returns                   Unsigned unsubmitted Create-Secret-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var addSecretToNftTx = function (id, secretOffchainData) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.addSecret, [id, secretOffchainData])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.addSecretToNftTx = addSecretToNftTx;
/**
 * @name addSecretToNft
 * @summary                   Adds a Secret to an NFT on chain.
 * @param id                  The ID of the NFT.
 * @param secretOffchainData  Off-chain related NFT secret metadata. Can be an IPFS hash, a URL or plain text.
 * @param keyring             Account that will sign the transaction.
 * @param waitUntil           Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns                   SecretAddedToNFTEvent Blockchain event.
 */
var addSecretToNft = function (id, secretOffchainData, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.addSecretToNftTx)(id, secretOffchainData)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.SecretAddedToNFTEvent)];
        }
    });
}); };
exports.addSecretToNft = addSecretToNft;
/**
 * @name burnNftTx
 * @summary   Creates an unsigned unsubmitted Burn-NFT Transaction Hash.
 * @param id  The ID of the NFT.
 * @returns   Unsigned unsubmitted Burn-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var burnNftTx = function (id) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.burnNft, [id])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.burnNftTx = burnNftTx;
/**
 * @name burnNft
 * @summary           Burns an NFT from the chain.
 * @param id          The ID of the NFT.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           NFTBurnedEvent Blockchain event.
 */
var burnNft = function (id, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.burnNftTx)(id)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.NFTBurnedEvent)];
        }
    });
}); };
exports.burnNft = burnNft;
/**
 * @name delegateNftTx
 * @summary           Creates an unsigned unsubmitted Delegate-NFT Transaction Hash.
 * @param id          The ID of the NFT.
 * @param recipient   Destination account. If set to undefined this functions acts as a way to undelegate a delegated NFT.
 * @returns           Unsigned unsubmitted Delegate-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var delegateNftTx = function (id, recipient) {
    if (recipient === void 0) { recipient = undefined; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.delegateNft, [id, recipient])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
};
exports.delegateNftTx = delegateNftTx;
/**
 * @name delegateNft
 * @summary           Delegates an NFT to someone.
 * @param id          The ID of the NFT.
 * @param recipient   Destination account. If set to undefined this functions acts as a way to undelegate a delegated NFT.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           NFTDelegatedEvent Blockchain event.
 */
var delegateNft = function (id, recipient, keyring, waitUntil) {
    if (recipient === void 0) { recipient = undefined; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx, events;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.delegateNftTx)(id, recipient)];
                case 1:
                    tx = _a.sent();
                    return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
                case 2:
                    events = (_a.sent()).events;
                    return [2 /*return*/, events.findEventOrThrow(events_1.NFTDelegatedEvent)];
            }
        });
    });
};
exports.delegateNft = delegateNft;
/**
 * @name setRoyaltyTx
 * @summary       Creates an unsigned unsubmitted Set-Royalty Transaction Hash.
 * @param id      The ID of the NFT.
 * @param amount  The new royalty value.
 * @returns       Unsigned unsubmitted Set-Royalty-NFT Transaction Hash. The Hash is only valid for 5 minutes.
 */
var setRoyaltyTx = function (id, amount) { return __awaiter(void 0, void 0, void 0, function () {
    var formattedRoyality;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                formattedRoyality = (0, utils_1.formatPermill)(amount);
                return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.setRoyalty, [id, formattedRoyality])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.setRoyaltyTx = setRoyaltyTx;
/**
 * @name setRoyalty
 * @summary           Sets the royalty of an NFT.
 * @param id          The ID of the NFT.
 * @param amount      The new royalty value.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           NFTRoyaltySetEvent Blockchain event.
 */
var setRoyalty = function (id, amount, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.setRoyaltyTx)(id, amount)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.NFTRoyaltySetEvent)];
        }
    });
}); };
exports.setRoyalty = setRoyalty;
/**
 * @name transferNftTx
 * @summary           Creates an unsigned unsubmitted Transfer-NFT Transaction Hash.
 * @param id          The ID of the NFT.
 * @param recipient   Destination account.
 * @returns           Unsigned unsubmitted Transfer-NFT Transaction Hash. The Hash is only valid for 5 minutes
 */
var transferNftTx = function (id, recipient) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.transferNft, [id, recipient])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.transferNftTx = transferNftTx;
/**
 * @name transferNft
 * @summary           Sends an NFT to someone.
 * @param id          The ID of the NFT.
 * @param recipient   Destination account.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           NFTTransferredEvent Blockchain event.
 */
var transferNft = function (id, recipient, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.transferNftTx)(id, recipient)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.NFTTransferredEvent)];
        }
    });
}); };
exports.transferNft = transferNft;
/**
 * @name addNftToCollectionTx
 * @summary               Creates an unsigned unsubmitted Add-NFT-To-Collection Transaction Hash.
 * @param nftId           The ID of the NFT.
 * @param collectionId    The ID of the Collection.
 * @returns               Unsigned unsubmitted Add-NFT-To-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
var addNftToCollectionTx = function (nftId, collectionId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.addNftToCollection, [nftId, collectionId])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.addNftToCollectionTx = addNftToCollectionTx;
/**
 * @name addNftToCollection
 * @summary               Adds an NFT to an existing collection.
 * @param nftId           The ID of the NFT.
 * @param collectionId    The ID of the Collection.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               NFTAddedToCollectionEvent Blockchain event.
 */
var addNftToCollection = function (nftId, collectionId, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.addNftToCollectionTx)(nftId, collectionId)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.NFTAddedToCollectionEvent)];
        }
    });
}); };
exports.addNftToCollection = addNftToCollection;
// Capsule
/**
 * @name convertNftToCapsuleTx
 * @summary    		              Creates an unsigned unsubmitted Convert-To-Capsule Transaction Hash for a Capsule NFT.
 * @param nftId		              The NFT Id to convert into a capsule.
 * @param capsuleOffchainData 	The offchain capsule data (a string)
 * @returns  		                Unsigned unsubmitted Convert-To-Capsule Transaction Hash. The Hash is only valid for 5 minutes.
 */
var convertNftToCapsuleTx = function (nftId, capsuleOffchainData) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.convertToCapsule, [nftId, capsuleOffchainData])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.convertNftToCapsuleTx = convertNftToCapsuleTx;
/**
 * @name convertNftToCapsule
 * @summary    		              Convert an existing basic NFT into a Capsule NFT.
 * @param nftId		              The NFT Id to convert in a capsule.
 * @param capsuleOffchainData 	The offchain capsule data (a string)
 * @param keyring               Account that will sign the transaction.
 * @param waitUntil             Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                NFTConvertedToCapsuleEvent Blockchain event.
 */
var convertNftToCapsule = function (nftId, capsuleOffchainData, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.convertNftToCapsuleTx)(nftId, capsuleOffchainData)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.NFTConvertedToCapsuleEvent)];
        }
    });
}); };
exports.convertNftToCapsule = convertNftToCapsule;
/**
 * @name createCapsuleTx
 * @summary    		             Creates an unsigned unsubmitted Create-Capsule Transaction Hash for a Capsule NFT.
 * @param offchainData         Off-chain data related to the NFT metadata. Can be an IPFS Hash, an URL or plain text.
 * @param capsuleOffchainData  Off-chain data related to the Capsule metadata. Can be an IPFS hash, a URL or plain text.
 * @param royalty              Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId         The collection to which the NFT belongs. Optional Parameter.
 * @param isSoulbound          If true, makes the Capsule intransferable. Default is false.
 * @returns  		               Unsigned unsubmitted Create-Capsule Transaction Hash. The Hash is only valid for 5 minutes.
 */
var createCapsuleTx = function (offchainData, capsuleOffchainData, royalty, collectionId, isSoulbound) {
    if (royalty === void 0) { royalty = 0; }
    if (collectionId === void 0) { collectionId = undefined; }
    if (isSoulbound === void 0) { isSoulbound = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var formattedRoyality;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    formattedRoyality = (0, utils_1.formatPermill)(royalty);
                    return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.createCapsule, [
                            offchainData,
                            capsuleOffchainData,
                            formattedRoyality,
                            collectionId,
                            isSoulbound,
                        ])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
};
exports.createCapsuleTx = createCapsuleTx;
/**
 * @name createCapsule
 * @summary    		              Convert an existing basic NFT into a Capsule NFT.
 * @param offchainData          Off-chain data related to the NFT metadata. Can be an IPFS Hash, an URL or plain text.
 * @param capsuleOffchainData   Off-chain data related to the Capsule metadata. Can be an IPFS hash, a URL or plain text.
 * @param royalty               Percentage of all second sales that the creator will receive. It's a decimal number in range [0, 100]. Default is 0.
 * @param collectionId          The collection to which the NFT belongs. Optional Parameter.
 * @param isSoulbound           If true, makes the Capsule intransferable. Default is false.
 * @param keyring               Account that will sign the transaction.
 * @param waitUntil             Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                Capsule NFT data combining the data from NFTCreatedEvent and NFTConvertedToCapsuleEvent.
 */
var createCapsule = function (offchainData, capsuleOffchainData, royalty, collectionId, isSoulbound, keyring, waitUntil) {
    if (royalty === void 0) { royalty = 0; }
    if (collectionId === void 0) { collectionId = undefined; }
    if (isSoulbound === void 0) { isSoulbound = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx, events, nftCreatedEvent, nftConvertedToCapsuleEvent;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.createCapsuleTx)(offchainData, capsuleOffchainData, royalty, collectionId, isSoulbound)];
                case 1:
                    tx = _a.sent();
                    return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
                case 2:
                    events = (_a.sent()).events;
                    nftCreatedEvent = events.findEventOrThrow(events_1.NFTCreatedEvent);
                    nftConvertedToCapsuleEvent = events.findEventOrThrow(events_1.NFTConvertedToCapsuleEvent);
                    return [2 /*return*/, {
                            nftId: nftCreatedEvent.nftId,
                            owner: nftCreatedEvent.owner,
                            creator: nftCreatedEvent.owner,
                            offchainData: nftCreatedEvent.offchainData,
                            capsuleOffchainData: nftConvertedToCapsuleEvent.offchainData,
                            royalty: nftCreatedEvent.royalty,
                            collectionId: nftCreatedEvent.collectionId,
                            isSoulbound: nftCreatedEvent.isSoulbound,
                        }];
            }
        });
    });
};
exports.createCapsule = createCapsule;
// /**
//  * @name revertCapsuleTx
//  * @summary    		    Creates an unsigned unsubmitted Revert-Capsule Transaction Hash for a Capsule NFT.
//  * @param nftId		    The NFT Id to remove the capsule part.
//  * @returns  		      Unsigned unsubmitted Revert-Capsule Transaction Hash. The Hash is only valid for 5 minutes.
//  */
// export const revertCapsuleTx = async (nftId: number): Promise<TransactionHashType> => {
//   return await createTxHex(txPallets.nft, txActions.revertCapsule, [nftId])
// }
// /**
//  * @name revertCapsule
//  * @summary		       Removes the capsule part of an NFT.
//  * @param nftId		   The NFT Id to remove the capsule part.
//  * @param keyring		 Account that will sign the transaction.
//  * @param waitUntil  Execution trigger that can be set either to BlockInclusion or BlockFinalization.
//  * @returns  		     CapsuleRevertedEvent Blockchain event.
//  */
// export const revertCapsule = async (
//   nftId: number,
//   keyring: IKeyringPair,
//   waitUntil: WaitUntil,
// ): Promise<CapsuleRevertedEvent> => {
//   const tx = await revertCapsuleTx(nftId)
//   const { events } = await submitTxBlocking(tx, waitUntil, keyring)
//   return events.findEventOrThrow(CapsuleRevertedEvent)
// }
/**
 * @name setCapsuleOffchaindataTx
 * @summary    		              Creates an unsigned unsubmitted Set-Capsule-Offchain-Data Transaction Hash for a Capsule NFT.
 * @param nftId		              The NFT Id to set the capsule's offchain data. Capsules are mutable
 * @param capsuleOffchainData 	The offchain capsule data (a string)
 * @returns  		                Unsigned unsubmitted Set-Capsule-Offchain-Data Transaction Hash. The Hash is only valid for 5 minutes.
 */
var setCapsuleOffchaindataTx = function (nftId, capsuleOffchainData) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.setCapsuleOffchaindata, [nftId, capsuleOffchainData])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.setCapsuleOffchaindataTx = setCapsuleOffchaindataTx;
/**
 * @name setCapsuleOffchaindata
 * @summary    		               Sets the offchain data of a Capsule NFT.
 * @param nftId		               The NFT Id to set the capsule's offchain data. Capsules are mutable
 * @param capsuleOffchainData 	 The offchain capsule data (a string)
 * @param keyring                Account that will sign the transaction.
 * @param waitUntil              Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                 CapsuleOffchainDataSetEvent Blockchain event.
 */
var setCapsuleOffchaindata = function (nftId, capsuleOffchainData, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.setCapsuleOffchaindataTx)(nftId, capsuleOffchainData)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.CapsuleOffchainDataSetEvent)];
        }
    });
}); };
exports.setCapsuleOffchaindata = setCapsuleOffchaindata;
/**
 * @name notifyEnclaveKeyUpdateTx
 * @summary    		   Creates an unsigned unsubmitted Notify-Enclave-Key-Update Transaction Hash for a Capsule NFT.
 * @param nftId		   The capsule NFT Id to signify that new keys were requested by the capsule owner.
 * @returns  		     Unsigned unsubmitted Notify-Enclave-Key-Update Transaction Hash. The Hash is only valid for 5 minutes.
 */
var notifyEnclaveKeyUpdateTx = function (nftId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.notifyEnclaveKeyUpdate, [nftId])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.notifyEnclaveKeyUpdateTx = notifyEnclaveKeyUpdateTx;
/**
 * @name notifyEnclaveKeyUpdate
 * @summary		       Notifies the enclave that capsule owner requests new keys.
 * @param nftId		   The capsule NFT Id to signify that new keys were requested by the capsule owner.
 * @param keyring		 Account that will sign the transaction.
 * @param waitUntil  Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		     CapsuleKeyUpdateNotifiedEvent Blockchain event.
 */
var notifyEnclaveKeyUpdate = function (nftId, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.notifyEnclaveKeyUpdateTx)(nftId)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.CapsuleKeyUpdateNotifiedEvent)];
        }
    });
}); };
exports.notifyEnclaveKeyUpdate = notifyEnclaveKeyUpdate;
// Collections
/**
 * @name createCollectionTx
 * @summary               Creates an unsigned unsubmitted Create-Collection Transaction Hash.
 * @param offchainData    Off-chain related Collection metadata. Can be an IPFS Hash, an URL or plain text.
 * @param limit           The maximum amount that NFTs that the collection can hold. This is optional
 * @returns               Unsigned unsubmitted Create-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
var createCollectionTx = function (offchainData, limit) {
    if (limit === void 0) { limit = undefined; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.createCollection, [offchainData, limit])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
};
exports.createCollectionTx = createCollectionTx;
/**
 * @name createCollection
 * @summary               Creates a collection.
 * @param offchainData    Off-chain related Collection metadata. Can be an IPFS Hash, an URL or plain text.
 * @param limit           Amount of NFTs that can be associated with this collection. This is optional
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               CollectionCreatedEvent Blockchain event.
 */
var createCollection = function (offchainData, limit, keyring, waitUntil) {
    if (limit === void 0) { limit = undefined; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx, events;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.createCollectionTx)(offchainData, limit)];
                case 1:
                    tx = _a.sent();
                    return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
                case 2:
                    events = (_a.sent()).events;
                    return [2 /*return*/, events.findEventOrThrow(events_1.CollectionCreatedEvent)];
            }
        });
    });
};
exports.createCollection = createCollection;
/**
 * @name limitCollectionTx
 * @summary       Creates an unsigned unsubmitted Limit-Collection Transaction Hash.
 * @param id      The ID of the Collection.
 * @param limit   Amount of NFTs that can be associated with this collection.
 * @returns       Unsigned unsubmitted Limit-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
var limitCollectionTx = function (id, limit) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.limitCollection, [id, limit])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.limitCollectionTx = limitCollectionTx;
/**
 * @name limitCollection
 * @summary           Limits how many NFTs can be associated with this collection.
 * @param id          The ID of the Collection.
 * @param limit       Amount of NFTs that can be associated with this collection.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           CollectionLimitedEvent Blockchain event.
 */
var limitCollection = function (id, limit, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.limitCollectionTx)(id, limit)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.CollectionLimitedEvent)];
        }
    });
}); };
exports.limitCollection = limitCollection;
/**
 * @name closeCollectionTx
 * @summary   Creates an unsigned unsubmitted Close-Collection Transaction Hash.
 * @param id  The ID of the Collection.
 * @returns   Unsigned unsubmitted Close-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
var closeCollectionTx = function (id) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.closeCollection, [id])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.closeCollectionTx = closeCollectionTx;
/**
 * @name closeCollection
 * @summary           Closes the collection so that no new NFTs can be added.
 * @param id          The ID of the Collection.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           CollectionClosedEvent Blockchain event.
 */
var closeCollection = function (id, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.closeCollectionTx)(id)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.CollectionClosedEvent)];
        }
    });
}); };
exports.closeCollection = closeCollection;
/**
 * @name burnCollectionTx
 * @summary   Creates an unsigned unsubmitted Burn-Collection Transaction Hash.
 * @param id  The ID of the Collection.
 * @returns   Unsigned unsubmitted Burn-Collection Transaction Hash. The Hash is only valid for 5 minutes.
 */
var burnCollectionTx = function (id) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.burnCollection, [id])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.burnCollectionTx = burnCollectionTx;
/**
 * @name burnCollection
 * @summary           Burns an existing collection. The collections needs to be empty before it can be burned.
 * @param id          The ID of the Collection.
 * @param keyring     Account that will sign the transaction.
 * @param waitUntil   Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns           CollectionBurnedEvent Blockchain event.
 */
var burnCollection = function (id, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.burnCollectionTx)(id)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.CollectionBurnedEvent)];
        }
    });
}); };
exports.burnCollection = burnCollection;
/**
 * @name setCollectionOffchaindataTx
 * @summary    		              Creates an unsigned unsubmitted Set-Collection-Offchain-Data Transaction Hash for a Collection.
 * @param id		                The ID of the Collection.
 * @param offchainData 	        The offchain collection data (a string)
 * @returns  		                Unsigned unsubmitted Set-Collection-Offchain-Data Transaction Hash. The Hash is only valid for 5 minutes.
 */
var setCollectionOffchaindataTx = function (id, offchainData) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.nft, constants_1.txActions.setCollectionOffchaindata, [id, offchainData])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.setCollectionOffchaindataTx = setCollectionOffchaindataTx;
/**
 * @name setCollectionOffchaindata
 * @summary    		               Sets the offchain data of a Collection.
 * @param id		                 The ID of the Collection.
 * @param offchainData 	         The offchain collection data (a string)
 * @param keyring                Account that will sign the transaction.
 * @param waitUntil              Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns  		                 CollectionOffchainDataSetEvent Blockchain event.
 */
var setCollectionOffchaindata = function (id, offchainData, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.setCollectionOffchaindataTx)(id, offchainData)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.CollectionOffchainDataSetEvent)];
        }
    });
}); };
exports.setCollectionOffchaindata = setCollectionOffchaindata;
