"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMarketplaceMetadata = exports.validateCollectionMetadata = exports.validateOptionalNFTMetadata = exports.validateNFTMetadata = exports.TernoaIPFS = void 0;
var formdata_node_1 = require("formdata-node");
var form_data_encoder_1 = require("form-data-encoder");
var stream_1 = require("stream");
var constants_1 = require("../constants");
var http_1 = require("./http");
/**
 * @implements {IServiceIPFS}
 */
var TernoaIPFS = /** @class */ (function () {
    function TernoaIPFS(apiUrl, apiKey) {
        if (apiUrl === void 0) { apiUrl = new URL("https://ipfs.ternoa.dev"); }
        /**
         * Service API `URL`.
         * @readonly
         */
        this.apiUrl = apiUrl;
        /**
         * Authorization token.
         *
         * @readonly
         */
        this.apiKey = apiKey;
    }
    TernoaIPFS.prototype.getFile = function (hash) {
        return _a.get(this, hash);
    };
    TernoaIPFS.prototype.storeFile = function (file) {
        return _a.storeFile(this, file);
    };
    TernoaIPFS.prototype.storeNFT = function (file, metadata) {
        return _a.storeNFT(this, file, metadata);
    };
    TernoaIPFS.prototype.storeSecretNFT = function (encryptedFile, encryptedFileType, publicKey, nftMetadata, mediaMetadata) {
        return _a.storeSecretNFT(this, encryptedFile, encryptedFileType, publicKey, nftMetadata, mediaMetadata);
    };
    TernoaIPFS.prototype.storeCapsuleNFT = function (publicKey, encryptedMedia, nftMetadata) {
        return _a.storeCapsuleNFT(this, publicKey, encryptedMedia, nftMetadata);
    };
    TernoaIPFS.prototype.storeCollection = function (profileFile, bannerFile, metadata) {
        return _a.storeCollection(this, profileFile, bannerFile, metadata);
    };
    TernoaIPFS.prototype.storeMarketplace = function (file, metadata) {
        return _a.storeMarketplace(this, file, metadata);
    };
    var _a;
    _a = TernoaIPFS;
    /**
     * Get file from IPFS.
     *
     * @param ternoaIpfsService
     * @param hash
     * @returns IPFS file
     */
    TernoaIPFS.get = function (_b, hash) {
        var apiUrl = _b.apiUrl;
        return __awaiter(void 0, void 0, void 0, function () {
            var httpClient, endpoint;
            return __generator(_a, function (_c) {
                httpClient = new http_1.HttpClient(apiUrl.toString());
                endpoint = "/ipfs/".concat(hash);
                return [2 /*return*/, httpClient.get(endpoint)];
            });
        });
    };
    /**
     * Upload file form data to IPFS.
     *
     * @param service
     * @param form
     * @returns IPFS data (hash, size, name)
     */
    TernoaIPFS.upload = function (_b, form) {
        var apiKey = _b.apiKey, apiUrl = _b.apiUrl;
        return __awaiter(void 0, void 0, void 0, function () {
            var httpClient, endpoint, headers, data, encoder;
            return __generator(_a, function (_c) {
                httpClient = new http_1.HttpClient(apiUrl.toString());
                endpoint = "/api/v0/add";
                headers = __assign({}, (apiKey && { apiKey: apiKey }));
                data = form;
                if (typeof process === "object" &&
                    typeof process.versions === "object" &&
                    typeof process.versions.node !== "undefined") {
                    encoder = new form_data_encoder_1.FormDataEncoder(form);
                    headers = __assign(__assign({}, headers), encoder.headers);
                    data = stream_1.Readable.from(encoder);
                }
                return [2 /*return*/, httpClient.post(endpoint, data, {
                        maxContentLength: 100000000, // 100mb
                        maxBodyLength: 1000000000, // 100mb
                        headers: headers,
                    })];
            });
        });
    };
    /**
     * Store a single file on IPFS.
     *
     * @param service
     * @param file
     * @returns IPFS data (hash, size, name)
     */
    TernoaIPFS.storeFile = function (service, file) { return __awaiter(void 0, void 0, void 0, function () {
        var form;
        return __generator(_a, function (_b) {
            switch (_b.label) {
                case 0:
                    form = new formdata_node_1.FormData();
                    form.append("file", file);
                    return [4 /*yield*/, _a.upload(service, form)];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
    /**
     * Store a Ternoa basic NFT's metadata & asset on IPFS.
     *
     * @param service
     * @param file      NFT's asset
     * @param metadata  Ternoa basic NFT metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-100-Basic-NFT.md#metadata here}.
     * @returns         IPFS data (Hash, Size, Name)
     */
    TernoaIPFS.storeNFT = function (service, file, metadata) { return __awaiter(void 0, void 0, void 0, function () {
        var res, hash, size, nftMetadata, metadataBlob, metadataFile;
        var _b;
        return __generator(_a, function (_c) {
            switch (_c.label) {
                case 0:
                    (0, exports.validateNFTMetadata)(metadata);
                    return [4 /*yield*/, _a.storeFile(service, file)];
                case 1:
                    res = _c.sent();
                    if (!res)
                        throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - Unable to upload NFT's asset"));
                    hash = res.Hash, size = res.Size;
                    nftMetadata = __assign(__assign({}, metadata), { image: hash, properties: __assign(__assign({}, metadata.properties), { media: __assign(__assign({}, (_b = metadata.properties) === null || _b === void 0 ? void 0 : _b.media), { hash: hash, size: size, type: file.type, name: file.name }) }) });
                    metadataBlob = new formdata_node_1.Blob([JSON.stringify(nftMetadata)], { type: "application/json" });
                    metadataFile = new formdata_node_1.File([metadataBlob], "NFT metadata");
                    return [4 /*yield*/, _a.storeFile(service, metadataFile)];
                case 2: return [2 /*return*/, _c.sent()];
            }
        });
    }); };
    /**
     * Store a Ternoa secret NFT's metadata & asset on IPFS.
     *
     * @param service
     * @param encryptedFile     NFT's encrypted asset.
     * @param encryptedFileType The original encrypted file type.
     * @param publicKey         Public key used to encrypt the Secret NFT.
     * @param nftMetadata       (Optional) Secret NFT metadata {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-520-Secret-nft.md here}.
     * @param mediaMetadata     (Optional) Secret NFT asset metadata.
     * @returns                 IPFS secret NFT data (Hash, Size, Name).
     */
    TernoaIPFS.storeSecretNFT = function (service, encryptedFile, encryptedFileType, publicKey, nftMetadata, mediaMetadata) { return __awaiter(void 0, void 0, void 0, function () {
        var publicKeyBlob, publicKeyFile, publicKeyRes, nftPublicKeyHash, blob, file, secretNFTRes, secretNFTHash, secretNFTSize, secretNFTMetadata, secretNFTMetadataBlob, secretNFTMetadataFile;
        var _b, _c;
        return __generator(_a, function (_d) {
            switch (_d.label) {
                case 0:
                    if (nftMetadata)
                        (0, exports.validateOptionalNFTMetadata)(nftMetadata);
                    if (typeof publicKey !== "string")
                        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Secret NFT's publicKey must be a string"));
                    publicKeyBlob = new formdata_node_1.Blob([publicKey], { type: "text/plain" });
                    publicKeyFile = new formdata_node_1.File([publicKeyBlob], "SecretNFT public key");
                    return [4 /*yield*/, _a.storeFile(service, publicKeyFile)];
                case 1:
                    publicKeyRes = _d.sent();
                    if (!publicKeyRes)
                        throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - Unable to upload secret NFT's public key"));
                    nftPublicKeyHash = publicKeyRes.Hash;
                    blob = new formdata_node_1.Blob([encryptedFile], { type: "text/plain" });
                    file = new formdata_node_1.File([blob], "SecretNFT metadata");
                    return [4 /*yield*/, _a.storeFile(service, file)];
                case 2:
                    secretNFTRes = _d.sent();
                    if (!secretNFTRes)
                        throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - Unable to upload secret NFT's asset"));
                    secretNFTHash = secretNFTRes.Hash, secretNFTSize = secretNFTRes.Size;
                    secretNFTMetadata = __assign(__assign({}, (nftMetadata && nftMetadata)), { properties: __assign(__assign({}, nftMetadata === null || nftMetadata === void 0 ? void 0 : nftMetadata.properties), { encrypted_media: __assign(__assign(__assign({}, (typeof ((_b = nftMetadata === null || nftMetadata === void 0 ? void 0 : nftMetadata.properties) === null || _b === void 0 ? void 0 : _b.encrypted_media) === "object" && ((_c = nftMetadata === null || nftMetadata === void 0 ? void 0 : nftMetadata.properties) === null || _c === void 0 ? void 0 : _c.encrypted_media))), { hash: secretNFTHash, type: encryptedFileType !== null && encryptedFileType !== void 0 ? encryptedFileType : file.type, size: secretNFTSize }), (mediaMetadata && mediaMetadata)), public_key_of_nft: nftPublicKeyHash }) });
                    secretNFTMetadataBlob = new formdata_node_1.Blob([JSON.stringify(secretNFTMetadata)], { type: "application/json" });
                    secretNFTMetadataFile = new formdata_node_1.File([secretNFTMetadataBlob], "secretNFT metadata");
                    return [4 /*yield*/, _a.storeFile(service, secretNFTMetadataFile)];
                case 3: return [2 /*return*/, _d.sent()];
            }
        });
    }); };
    /**
     * Store a Ternoa Capsule NFT's metadata & assets on IPFS.
     *
     * @param service
     * @param publicKey         Public key used to encrypt the Capsule NFT.
     * @param encryptedMedia    An array of NFT's encrypted asset.
     * @param nftMetadata       (Optional) Capsule NFT metadata {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-530-Capsule.md here}.
     * @returns                 IPFS Capsule data (Hash, Size, Name).
     */
    TernoaIPFS.storeCapsuleNFT = function (service, publicKey, encryptedMedia, nftMetadata) { return __awaiter(void 0, void 0, void 0, function () {
        var publicKeyBlob, publicKeyFile, publicKeyRes, nftPublicKeyHash, capsuleMedia, capsuleMetadata, capsuleNFTMetadataBlob, capsuleNFTMetadataFile;
        return __generator(_a, function (_b) {
            switch (_b.label) {
                case 0:
                    if (nftMetadata)
                        (0, exports.validateOptionalNFTMetadata)(nftMetadata);
                    if (typeof publicKey !== "string")
                        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Capsule NFT's publicKey must be a string"));
                    publicKeyBlob = new formdata_node_1.Blob([publicKey], { type: "text/plain" });
                    publicKeyFile = new formdata_node_1.File([publicKeyBlob], "SecretNFT public key");
                    return [4 /*yield*/, _a.storeFile(service, publicKeyFile)];
                case 1:
                    publicKeyRes = _b.sent();
                    if (!publicKeyRes)
                        throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - Unable to upload secret NFT's public key"));
                    nftPublicKeyHash = publicKeyRes.Hash;
                    capsuleMedia = [];
                    return [4 /*yield*/, Promise.all(encryptedMedia.map(function (_b) { return __awaiter(void 0, void 0, void 0, function () {
                            var blob, file, _c, mediaHash, mediaSize, media;
                            var encryptedFile = _b.encryptedFile, type = _b.type, rest = __rest(_b, ["encryptedFile", "type"]);
                            return __generator(this, function (_d) {
                                switch (_d.label) {
                                    case 0:
                                        blob = new formdata_node_1.Blob([encryptedFile], { type: "text/plain" });
                                        file = new formdata_node_1.File([blob], "capsuleMediaNFT");
                                        return [4 /*yield*/, _a.storeFile(service, file)];
                                    case 1:
                                        _c = _d.sent(), mediaHash = _c.Hash, mediaSize = _c.Size;
                                        if (!mediaHash)
                                            throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - Unable to upload capsule NFT's media"));
                                        media = __assign({ hash: mediaHash, type: type, size: Number(mediaSize) }, rest);
                                        capsuleMedia.push(media);
                                        return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 2:
                    _b.sent();
                    capsuleMetadata = __assign(__assign({}, (nftMetadata && nftMetadata)), { properties: __assign(__assign({}, nftMetadata === null || nftMetadata === void 0 ? void 0 : nftMetadata.properties), { encrypted_media: capsuleMedia, public_key_of_nft: nftPublicKeyHash }) });
                    capsuleNFTMetadataBlob = new formdata_node_1.Blob([JSON.stringify(capsuleMetadata)], { type: "application/json" });
                    capsuleNFTMetadataFile = new formdata_node_1.File([capsuleNFTMetadataBlob], "capsuleNFT metadata");
                    return [4 /*yield*/, _a.storeFile(service, capsuleNFTMetadataFile)];
                case 3: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
    /**
     * Store a single Ternoa Collection's metadata & assets on IPFS.
     *
     * @param service
     * @param profileFile   Collection's profile asset
     * @param bannerFile    Collection's banner asset
     * @param metadata      Ternoa Collection metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-101-Collection.md#metadata here}.
     * @returns             IPFS data (Hash, Size, Name)
     */
    TernoaIPFS.storeCollection = function (service, profileFile, bannerFile, metadata) { return __awaiter(void 0, void 0, void 0, function () {
        var profileRes, bannerRes, collectionMetadata, metadataBlob, metadataFile;
        return __generator(_a, function (_b) {
            switch (_b.label) {
                case 0:
                    (0, exports.validateCollectionMetadata)(metadata);
                    return [4 /*yield*/, _a.storeFile(service, profileFile)];
                case 1:
                    profileRes = _b.sent();
                    if (!profileRes)
                        throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - Unable to upload collection's profile asset"));
                    return [4 /*yield*/, _a.storeFile(service, bannerFile)];
                case 2:
                    bannerRes = _b.sent();
                    if (!bannerRes)
                        throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - Unable to upload collection's banner asset"));
                    collectionMetadata = __assign(__assign({}, metadata), { profile_image: profileRes.Hash, banner_image: bannerRes.Hash });
                    metadataBlob = new formdata_node_1.Blob([JSON.stringify(collectionMetadata)], { type: "application/json" });
                    metadataFile = new formdata_node_1.File([metadataBlob], "Collection metadata");
                    return [4 /*yield*/, _a.storeFile(service, metadataFile)];
                case 3: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
    /**
     * Store a single Ternoa Marketplace's metadata & asset on IPFS.
     *
     * @param service
     * @param file      Marketplace's logo asset
     * @param metadata  Ternoa Marketplace metadata structure {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-200-Marketplace.md#metadata here}.
     * @returns         IPFS data (Hash, Size, Name)
     */
    TernoaIPFS.storeMarketplace = function (service, file, metadata) { return __awaiter(void 0, void 0, void 0, function () {
        var res, collectionMetadata, metadataBlob, metadataFile;
        return __generator(_a, function (_b) {
            switch (_b.label) {
                case 0:
                    (0, exports.validateMarketplaceMetadata)(metadata);
                    return [4 /*yield*/, _a.storeFile(service, file)];
                case 1:
                    res = _b.sent();
                    if (!res)
                        throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - Unable to upload marketplace's logo asset"));
                    collectionMetadata = __assign(__assign({}, metadata), { logo: res.Hash });
                    metadataBlob = new formdata_node_1.Blob([JSON.stringify(collectionMetadata)], { type: "application/json" });
                    metadataFile = new formdata_node_1.File([metadataBlob], "Collection metadata");
                    return [4 /*yield*/, _a.storeFile(service, metadataFile)];
                case 2: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
    return TernoaIPFS;
}());
exports.TernoaIPFS = TernoaIPFS;
var validateNFTMetadata = function (_b) {
    var title = _b.title, description = _b.description;
    if (!title)
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : NFT's title is required"));
    else if (typeof title !== "string") {
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : NFT's title must be a string"));
    }
    if (!description)
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : NFT's description is required"));
    else if (typeof description !== "string") {
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : NFT's description must be a string"));
    }
};
exports.validateNFTMetadata = validateNFTMetadata;
var validateOptionalNFTMetadata = function (_b) {
    var title = _b.title, description = _b.description;
    if (title !== undefined && typeof title !== "string") {
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Secret NFT's title must be a string"));
    }
    if (description !== undefined && typeof description !== "string") {
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Secret NFT's description must be a string"));
    }
};
exports.validateOptionalNFTMetadata = validateOptionalNFTMetadata;
var validateCollectionMetadata = function (_b) {
    var name = _b.name, description = _b.description;
    if (!name)
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Collection's name is required"));
    else if (typeof name !== "string") {
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Collection's name must be a string"));
    }
    if (!name)
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Collection's description is required"));
    else if (typeof description !== "string") {
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Collection's description must be a string"));
    }
};
exports.validateCollectionMetadata = validateCollectionMetadata;
var validateMarketplaceMetadata = function (_b) {
    var name = _b.name;
    if (!name)
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Marketplace's name is required"));
    else if (typeof name !== "string") {
        throw new TypeError("".concat(constants_1.Errors.IPFS_METADATA_VALIDATION_ERROR, " : Marketplace's name must be a string"));
    }
};
exports.validateMarketplaceMetadata = validateMarketplaceMetadata;
