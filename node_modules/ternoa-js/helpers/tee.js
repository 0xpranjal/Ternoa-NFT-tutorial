"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.teeNFTReconciliation = exports.formatReconciliationIntervalPayload = exports.teeKeySharesRemove = exports.teeKeySharesRetrieve = exports.sharesAvailableOnTeeCluster = exports.teeKeySharesStore = exports.teePost = exports.formatRetrievePayload = exports.formatStorePayload = exports.getTeeEnclaveSharesAvailablility = exports.getTeeEnclavesBaseUrl = exports.getFirstPublicClusterAvailable = exports.getPublicsClusters = exports.getEnclavesQuote = exports.getEnclaveDataAndHealth = exports.populateEnclavesData = exports.getEnclaveHealthStatus = exports.combineKeyShares = exports.generateKeyShares = exports.SIGNER_BLOCK_VALIDITY = exports.RECONCILIATION_NFT_INTERVAL = exports.TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT = exports.TEE_REMOVE_CAPSULE_NFT_KEYSHARE_ENDPOINT = exports.TEE_RETRIEVE_CAPSULE_NFT_ENDPOINT = exports.TEE_STORE_CAPSULE_NFT_ENDPOINT = exports.TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT = exports.TEE_REMOVE_SECRET_NFT_KEYSHARE_ENDPOINT = exports.TEE_RETRIEVE_SECRET_NFT_ENDPOINT = exports.TEE_STORE_SECRET_NFT_ENDPOINT = exports.TEE_QUOTE_ENDPOINT = exports.TEE_HEALTH_ENDPOINT = exports.ENCLAVES_IN_CLUSTER = exports.SSSA_THRESHOLD = exports.SSSA_NUMSHARES = void 0;
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
var sssa_js_1 = require("sssa-js");
var buffer_1 = require("buffer");
var util_1 = require("@polkadot/util");
var crypto_1 = require("crypto");
var crypto_2 = require("./crypto");
var http_1 = require("./http");
var utils_1 = require("./utils");
var tee_1 = require("../tee");
var constants_1 = require("../constants");
var blockchain_1 = require("../blockchain");
exports.SSSA_NUMSHARES = 5;
exports.SSSA_THRESHOLD = 3;
exports.ENCLAVES_IN_CLUSTER = 5;
var TEE_STORE_STATUS_SUCCESS = "STORESUCCESS";
var TEE_RETRIEVE_STATUS_SUCCESS = "RETRIEVESUCCESS";
exports.TEE_HEALTH_ENDPOINT = "/api/health";
exports.TEE_QUOTE_ENDPOINT = "/api/quote";
exports.TEE_STORE_SECRET_NFT_ENDPOINT = "/api/secret-nft/store-keyshare";
exports.TEE_RETRIEVE_SECRET_NFT_ENDPOINT = "/api/secret-nft/retrieve-keyshare";
exports.TEE_REMOVE_SECRET_NFT_KEYSHARE_ENDPOINT = "/api/secret-nft/remove-keyshare";
var TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT = function (nftId) {
    return "/api/secret-nft/is-keyshare-available/".concat(nftId);
};
exports.TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT = TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT;
exports.TEE_STORE_CAPSULE_NFT_ENDPOINT = "/api/capsule-nft/set-keyshare";
exports.TEE_RETRIEVE_CAPSULE_NFT_ENDPOINT = "/api/capsule-nft/retrieve-keyshare";
exports.TEE_REMOVE_CAPSULE_NFT_KEYSHARE_ENDPOINT = "/api/capsule-nft/remove-keyshare";
var TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT = function (nftId) {
    return "/api/capsule-nft/is-keyshare-available/".concat(nftId);
};
exports.TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT = TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT;
exports.RECONCILIATION_NFT_INTERVAL = "/api/metric/interval-nft-list";
exports.SIGNER_BLOCK_VALIDITY = 15;
/**
 * @name generateKeyShares
 * @summary     Generates an array of shares from the incoming parameter string.
 * @param data  The data to split into shares (e.g. private key).
 * @returns     An array of stringified shares.
 */
var generateKeyShares = function (data) {
    var shares = (0, sssa_js_1.create)(exports.SSSA_THRESHOLD, exports.SSSA_NUMSHARES, data);
    var base64shares = shares.map(function (share) { return buffer_1.Buffer.from(share).toString("base64"); });
    return base64shares;
};
exports.generateKeyShares = generateKeyShares;
/**
 * @name combineKeyShares
 * @summary       Combines an array of shares to reconstruct data.
 * @param shares  Array of stringified shares.
 * @returns       The original data reconstructed.
 */
var combineKeyShares = function (shares) {
    var filteredShares = shares.filter(function (x) { return x; });
    if (filteredShares.length < exports.SSSA_THRESHOLD)
        throw new Error("".concat(constants_1.Errors.TEE_RETRIEVE_ERROR, " - CANNOT_COMBINE_SHARES: expected a minimum of ").concat(exports.SSSA_THRESHOLD, " shares."));
    var hexShares = filteredShares.map(function (bufferShare) { return buffer_1.Buffer.from(bufferShare, "base64").toString("utf-8"); });
    var combinedShares = (0, sssa_js_1.combine)(hexShares);
    return combinedShares;
};
exports.combineKeyShares = combineKeyShares;
/**
 * @name getEnclaveHealthStatus
 * @summary           Check that all TEE enclaves from a cluster are ready to be used.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave information (status, date, description, addresses)
 */
var getEnclaveHealthStatus = function (clusterId) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var teeEnclaves, clusterHealthCheck;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.getTeeEnclavesBaseUrl)(clusterId)];
                case 1:
                    teeEnclaves = _a.sent();
                    return [4 /*yield*/, Promise.all(teeEnclaves.map(function (enclaveUrl, idx) { return __awaiter(void 0, void 0, void 0, function () {
                            var http, enclaveData, isError;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        http = new http_1.HttpClient((0, utils_1.ensureHttps)(enclaveUrl));
                                        return [4 /*yield*/, http.getRaw(exports.TEE_HEALTH_ENDPOINT)];
                                    case 1:
                                        enclaveData = _a.sent();
                                        isError = enclaveData.status !== 200;
                                        if (isError || !enclaveData.sync_state.length || enclaveData.sync_state == "setup")
                                            throw new Error("".concat(constants_1.Errors.TEE_ENCLAVE_NOT_AVAILBLE, " - ID ").concat(idx, ", URL: ").concat(enclaveUrl, ". ").concat(enclaveData.description));
                                        return [2 /*return*/, enclaveData];
                                }
                            });
                        }); }))];
                case 2:
                    clusterHealthCheck = _a.sent();
                    return [2 /*return*/, clusterHealthCheck];
            }
        });
    });
};
exports.getEnclaveHealthStatus = getEnclaveHealthStatus;
/**
 * @name populateEnclavesData
 * @summary           Populate enclaves data with addresses, slot and urls.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of the TEE enclaves data for the cluster.
 */
var populateEnclavesData = function (clusterId) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var clusterData, data;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, tee_1.getClusterData)(clusterId)];
                case 1:
                    clusterData = _a.sent();
                    if (!clusterData)
                        throw new Error(constants_1.Errors.TEE_CLUSTER_NOT_FOUND);
                    if (clusterData.enclaves.length === 0)
                        throw new Error("".concat(constants_1.Errors.TEE_CLUSTER_IS_EMPTY, ": ").concat(clusterId));
                    return [4 /*yield*/, Promise.all(clusterData.enclaves.map(function (enclave) { return __awaiter(void 0, void 0, void 0, function () {
                            var enclaveData;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, (0, tee_1.getEnclaveData)(enclave[0])];
                                    case 1:
                                        enclaveData = _a.sent();
                                        if (!enclaveData)
                                            throw new Error(constants_1.Errors.TEE_ENCLAVE_NOT_FOUND);
                                        return [2 /*return*/, {
                                                clusterId: clusterId,
                                                clusterType: clusterData.clusterType,
                                                enclaveAddress: enclaveData.enclaveAddress,
                                                operatorAddress: enclave[0],
                                                enclaveUrl: (0, utils_1.removeURLSlash)((0, util_1.hexToString)(enclaveData.apiUri)),
                                                enclaveSlot: enclave[1],
                                            }];
                                }
                            });
                        }); }))];
                case 2:
                    data = _a.sent();
                    return [2 /*return*/, data];
            }
        });
    });
};
exports.populateEnclavesData = populateEnclavesData;
/**
 * @name getEnclaveDataAndHealth
 * @summary           Get the enclaves data from a cluster populated with health check.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave data populated with its health information.
 */
var getEnclaveDataAndHealth = function (clusterId) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var teeEnclaves, enclaveData;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.populateEnclavesData)(clusterId)];
                case 1:
                    teeEnclaves = _a.sent();
                    return [4 /*yield*/, Promise.all(teeEnclaves.map(function (e, idx) { return __awaiter(void 0, void 0, void 0, function () {
                            var http, enclaveHealthData, block_number, sync_state, version, description, status_1, error_1, blockNumber, description;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 2, , 4]);
                                        http = new http_1.HttpClient((0, utils_1.ensureHttps)(e.enclaveUrl));
                                        return [4 /*yield*/, http.getRaw(exports.TEE_HEALTH_ENDPOINT)];
                                    case 1:
                                        enclaveHealthData = _a.sent();
                                        block_number = enclaveHealthData.block_number, sync_state = enclaveHealthData.sync_state, version = enclaveHealthData.version, description = enclaveHealthData.description, status_1 = enclaveHealthData.status;
                                        return [2 /*return*/, __assign(__assign({}, e), { status: status_1, blockNumber: block_number, syncState: sync_state, description: description, version: version })];
                                    case 2:
                                        error_1 = _a.sent();
                                        return [4 /*yield*/, (0, crypto_2.getLastBlock)()];
                                    case 3:
                                        blockNumber = _a.sent();
                                        description = error_1 instanceof Error ? "SGX_SERVER_ERROR - ".concat(error_1.message) : "SGX_SERVER_ERROR - ENCLAVE UNREACHABLE";
                                        return [2 /*return*/, __assign(__assign({}, teeEnclaves[idx]), { status: 500, blockNumber: blockNumber, syncState: "Internal Error", description: description })];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 2:
                    enclaveData = _a.sent();
                    return [2 /*return*/, enclaveData];
            }
        });
    });
};
exports.getEnclaveDataAndHealth = getEnclaveDataAndHealth;
/**
 * @name getEnclavesQuote
 * @summary           Generate the enclaves quote.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of JSONs containing each enclave quote information (status, data or error)
 */
var getEnclavesQuote = function (clusterId) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var teeEnclaves, clusterQuote;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.populateEnclavesData)(clusterId)];
                case 1:
                    teeEnclaves = _a.sent();
                    return [4 /*yield*/, Promise.all(teeEnclaves.map(function (e, idx) { return __awaiter(void 0, void 0, void 0, function () {
                            var http, enclaveData, status_2, data, block_number, error_2, description;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 2, , 3]);
                                        http = new http_1.HttpClient((0, utils_1.ensureHttps)(e.enclaveUrl));
                                        return [4 /*yield*/, http.getRaw(exports.TEE_QUOTE_ENDPOINT)];
                                    case 1:
                                        enclaveData = _a.sent();
                                        status_2 = enclaveData.status, data = enclaveData.data, block_number = enclaveData.block_number;
                                        return [2 /*return*/, __assign(__assign({}, e), { status: status_2, data: data, blockNumber: block_number })];
                                    case 2:
                                        error_2 = _a.sent();
                                        description = error_2 instanceof Error
                                            ? "INTERNAL_SGX_SERVER_ERROR - ".concat(error_2.message)
                                            : "INTERNAL_SGX_SERVER_ERROR - QUOTE_NOT_AVAILABLE";
                                        return [2 /*return*/, __assign(__assign({}, teeEnclaves[idx]), { status: 500, data: description })];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 2:
                    clusterQuote = _a.sent();
                    return [2 /*return*/, clusterQuote];
            }
        });
    });
};
exports.getEnclavesQuote = getEnclavesQuote;
/**
 * @name getPublicsClusters
 * @summary           Provides the list of the availables publics clusters.
 * @returns           An array of publics clusterId.
 */
var getPublicsClusters = function () { return __awaiter(void 0, void 0, void 0, function () {
    var nextClusterId, clustersList, i, data, result, enclaves, clusterType, error_3;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, tee_1.getNextClusterIdAvailable)()];
            case 1:
                nextClusterId = _a.sent();
                clustersList = [];
                i = 0;
                _a.label = 2;
            case 2:
                if (!(i < nextClusterId)) return [3 /*break*/, 7];
                _a.label = 3;
            case 3:
                _a.trys.push([3, 5, , 6]);
                return [4 /*yield*/, (0, blockchain_1.query)(constants_1.txPallets.tee, constants_1.chainQuery.clusterData, [i])];
            case 4:
                data = _a.sent();
                result = data.toJSON();
                if (result) {
                    enclaves = result.enclaves, clusterType = result.clusterType;
                    // CHECK PUBLIC CLUSTERS WITH THE 5 ENCLAVES WORKING
                    if (enclaves.length === exports.ENCLAVES_IN_CLUSTER && clusterType === "Public") {
                        clustersList.push(i);
                    }
                }
                return [3 /*break*/, 6];
            case 5:
                error_3 = _a.sent();
                return [3 /*break*/, 6];
            case 6:
                i++;
                return [3 /*break*/, 2];
            case 7: return [2 /*return*/, clustersList];
        }
    });
}); };
exports.getPublicsClusters = getPublicsClusters;
/**
 * @name getFirstPublicClusterAvailable
 * @summary           Provides the id of the first available public cluster.
 * @returns           A clusterId as a number.
 */
var getFirstPublicClusterAvailable = function () { return __awaiter(void 0, void 0, void 0, function () {
    var nextClusterId, i, data, result, enclaves, clusterType, error_4;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, tee_1.getNextClusterIdAvailable)()];
            case 1:
                nextClusterId = _a.sent();
                i = 0;
                _a.label = 2;
            case 2:
                if (!(i < nextClusterId)) return [3 /*break*/, 7];
                _a.label = 3;
            case 3:
                _a.trys.push([3, 5, , 6]);
                return [4 /*yield*/, (0, blockchain_1.query)(constants_1.txPallets.tee, constants_1.chainQuery.clusterData, [i])];
            case 4:
                data = _a.sent();
                result = data.toJSON();
                if (result) {
                    enclaves = result.enclaves, clusterType = result.clusterType;
                    // CHECK PUBLIC CLUSTER WITH THE 5 ENCLAVES WORKING
                    if (enclaves.length === exports.ENCLAVES_IN_CLUSTER && clusterType === "Public") {
                        return [2 /*return*/, i];
                    }
                }
                return [3 /*break*/, 6];
            case 5:
                error_4 = _a.sent();
                return [3 /*break*/, 6];
            case 6:
                i++;
                return [3 /*break*/, 2];
            case 7: return [2 /*return*/];
        }
    });
}); };
exports.getFirstPublicClusterAvailable = getFirstPublicClusterAvailable;
/**
 * @name getTeeEnclavesBaseUrl
 * @summary           Retrieves the TEE enclaves urls stored on-chain.
 * @param clusterId   The TEE Cluster id.
 * @returns           An array of the TEE enclaves urls available.
 */
var getTeeEnclavesBaseUrl = function (clusterId) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var clusterData, urls;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, tee_1.getClusterData)(clusterId)];
                case 1:
                    clusterData = _a.sent();
                    if (!clusterData)
                        throw new Error(constants_1.Errors.TEE_CLUSTER_NOT_FOUND);
                    if (clusterData.enclaves.length === 0)
                        throw new Error("".concat(constants_1.Errors.TEE_CLUSTER_IS_EMPTY, ": ").concat(clusterId));
                    return [4 /*yield*/, Promise.all(clusterData.enclaves.map(function (enclave) { return __awaiter(void 0, void 0, void 0, function () {
                            var enclaveData;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, (0, tee_1.getEnclaveData)(enclave[0])];
                                    case 1:
                                        enclaveData = _a.sent();
                                        if (!enclaveData)
                                            throw new Error(constants_1.Errors.TEE_ENCLAVE_NOT_FOUND);
                                        return [2 /*return*/, (0, utils_1.removeURLSlash)((0, util_1.hexToString)(enclaveData === null || enclaveData === void 0 ? void 0 : enclaveData.apiUri))];
                                }
                            });
                        }); }))];
                case 2:
                    urls = _a.sent();
                    return [2 /*return*/, urls];
            }
        });
    });
};
exports.getTeeEnclavesBaseUrl = getTeeEnclavesBaseUrl;
/**
 * @name getEnclaveSharesAvailablility
 * @summary           Check that an enclave from a cluster have registered a Capsule NFT or a Secret NFT's key shares
 * @param enclave     The enclave base url.
 * @param nftId       The Capsule NFT id or Secret NFT id to check key registration on enclave.
 * @param kind        The kind of NFT linked to the key being checked: "secret" or "capsule"
 * @returns           A JSON containing the enclave share availability (enclave_id, nft_id, an exists status (boolean))
 */
var getTeeEnclaveSharesAvailablility = function (enclave, nftId, kind) { return __awaiter(void 0, void 0, void 0, function () {
    var http, endpoint;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (kind !== "secret" && kind !== "capsule") {
                    throw new Error("".concat(constants_1.Errors.TEE_ERROR, ": Kind must be either \"secret\" or \"capsule\""));
                }
                http = new http_1.HttpClient((0, utils_1.ensureHttps)(enclave));
                endpoint = kind === "secret"
                    ? (0, exports.TEE_AVAILABLE_SECRET_NFT_KEYSHARE_ENDPOINT)(nftId)
                    : (0, exports.TEE_AVAILABLE_CAPSULE_NFT_KEYSHARE_ENDPOINT)(nftId);
                return [4 /*yield*/, http.get(endpoint)];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.getTeeEnclaveSharesAvailablility = getTeeEnclaveSharesAvailablility;
/**
 * @name formatStorePayload
 * @summary                     Prepares post request payload to store secret/capsule NFT data into TEE enclaves.
 * @param ownerAddress          Address of the NFT's owner.
 * @param signerAuthMessage     The message to be signed by the owner to autenticate the tempory signer used to sign shares.
 * @param signerAuthSignature   The signerAuthMessage message signed by the NFT owner.
 * @param signerPair            The temporary signer account used to sign shares.
 * @param nftId                 The ID of the NFT.
 * @param share                 A share of the private key used to decrypt the NFT.
 * @param blockId               The current block header id on-chain.
 * @param blockValidity         A block duration validity for the temporay signer account to be valid; default SIGNER_BLOCK_VALIDITY = 100 blocks.
 * @returns                     Payload object ready to be submitted to TEE enclaves.
 */
var formatStorePayload = function (ownerAddress, signerAuthMessage, signerAuthSignature, signerPair, nftId, share, blockId, blockValidity) {
    if (blockValidity === void 0) { blockValidity = exports.SIGNER_BLOCK_VALIDITY; }
    var data = "<Bytes>".concat(nftId, "_").concat(share, "_").concat(blockId, "_").concat(blockValidity, "</Bytes>");
    var dataSignature = (0, crypto_2.getSignatureFromKeyring)(signerPair, data);
    return {
        owner_address: ownerAddress,
        signer_address: signerAuthMessage,
        data: data,
        signature: dataSignature,
        signersig: signerAuthSignature,
    };
};
exports.formatStorePayload = formatStorePayload;
/**
 * @name formatRetrievePayload
 * @summary                  Prepares post request payload to retrieve secret/capsule NFT data into TEE enclaves.
 * @param requester          The NFT owner account (keyring) or address (string) used to sign data. It can also be the retriever account of rentee or delegatee.
 * @param requesterRole      Kind of account that want to retrieve the payload: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param nftId              The ID of the NFT.
 * @param blockId            The current block header id on-chain.
 * @param blockValidity      A block duration validity for the temporay signer account to be valid; default SIGNER_BLOCK_VALIDITY = 100 blocks.
 * @param extensionInjector  (Optional)The signer method retrived from your extension. We recommand Polkadot extention: object must have a signer key.
 * @returns                  Payload ready to be submitted to TEE enclaves.
 */
var formatRetrievePayload = function (requester, requesterRole, nftId, blockId, blockValidity, extensionInjector) {
    if (blockValidity === void 0) { blockValidity = exports.SIGNER_BLOCK_VALIDITY; }
    return __awaiter(void 0, void 0, void 0, function () {
        var data, signature, _a, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (typeof requester === "string" && !(0, blockchain_1.isValidAddress)(requester))
                        throw new Error("INVALID_ADDRESS_FORMAT");
                    if (typeof requester === "string" && !extensionInjector)
                        throw new Error("".concat(constants_1.Errors.TEE_RETRIEVE_ERROR, " - INJECTOR_SIGNER_MISSING : injectorSigner must be provided when signer is of type string"));
                    data = "<Bytes>".concat(nftId, "_").concat(blockId, "_").concat(blockValidity, "</Bytes>");
                    if (!(typeof requester === "string")) return [3 /*break*/, 3];
                    _b = extensionInjector;
                    if (!_b) return [3 /*break*/, 2];
                    return [4 /*yield*/, (0, crypto_2.getSignatureFromExtension)(requester, extensionInjector, data)];
                case 1:
                    _b = (_c.sent());
                    _c.label = 2;
                case 2:
                    _a = _b;
                    return [3 /*break*/, 4];
                case 3:
                    _a = (0, crypto_2.getSignatureFromKeyring)(requester, data);
                    _c.label = 4;
                case 4:
                    signature = _a;
                    if (!signature)
                        throw new Error("".concat(constants_1.Errors.TEE_RETRIEVE_ERROR, " : cannot get signature when retrieving payload"));
                    return [2 /*return*/, {
                            requester_address: typeof requester === "string" ? requester : requester.address,
                            requester_type: requesterRole,
                            data: data,
                            signature: signature,
                        }];
            }
        });
    });
};
exports.formatRetrievePayload = formatRetrievePayload;
/**
 * @name teePost
 * @summary               Upload secret payload data to an TEE enclave.
 * @param http            HttpClient instance.
 * @param endpoint        TEE enclave endpoint.
 * @param secretPayload   Payload formatted with the required secret NFT's data.
 * @returns               TEE enclave response.
 */
var teePost = function (http, endpoint, secretPayload) { return __awaiter(void 0, void 0, void 0, function () {
    var headers;
    return __generator(this, function (_a) {
        headers = {
            "Content-Type": "application/json",
        };
        return [2 /*return*/, http.post(endpoint, secretPayload, {
                headers: headers,
            })];
    });
}); };
exports.teePost = teePost;
/**
 * @name teeKeySharesStore
 * @summary               Upload secret shares to TEE enclaves with retry.
 * @param clusterId       The TEE Cluster id to upload shares to.
 * @param kind            The kind of nft linked to the key uploaded: "secret" or "capsule"
 * @param payloads        Array of payloads containing secret data and each share of the private key. Should contain *SSSA_NUMSHARES* payloads.
 * @param nbRetry         The number of retry that need to be proceeded in case of fail during a share upload. Default is 3.
 * @param enclavesIndex   Optional: An Array of enclaves index. For example, some enclaves that previously failed that need to be uploaded again.
 * @returns               TEE enclave response including both the payload and the enclave response.
 */
var teeKeySharesStore = function (clusterId, kind, payloads, nbRetry, enclavesIndex) {
    if (clusterId === void 0) { clusterId = 0; }
    if (nbRetry === void 0) { nbRetry = 3; }
    return __awaiter(void 0, void 0, void 0, function () {
        var nbShares, teeEnclaves, teeRes;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (kind !== "secret" && kind !== "capsule") {
                        throw new Error("".concat(constants_1.Errors.TEE_UPLOAD_ERROR, " : Kind must be either \"secret\" or \"capsule\""));
                    }
                    nbShares = enclavesIndex && enclavesIndex.length > 0 && enclavesIndex.length <= exports.SSSA_NUMSHARES
                        ? enclavesIndex.length
                        : exports.SSSA_NUMSHARES;
                    if (payloads.length !== nbShares)
                        throw new Error("".concat(constants_1.Errors.NOT_CORRECT_AMOUNT_TEE_PAYLOADS, " - Got: ").concat(payloads.length, "; Expected: ").concat(exports.SSSA_NUMSHARES));
                    return [4 /*yield*/, (0, exports.populateEnclavesData)(clusterId)];
                case 1:
                    teeEnclaves = _a.sent();
                    if (teeEnclaves.length !== exports.SSSA_NUMSHARES)
                        throw new Error("".concat(constants_1.Errors.NOT_CORRECT_AMOUNT_TEE_ENCLAVES, " - Got: ").concat(teeEnclaves.length, "; Expected: ").concat(exports.SSSA_NUMSHARES));
                    return [4 /*yield*/, Promise.all(payloads.map(function (payload, idx) { return __awaiter(void 0, void 0, void 0, function () {
                            var _a, enclaveUrl, enclaveAddress, operatorAddress, enclaveSlot, http, endpoint, post, retryFn;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = teeEnclaves[enclavesIndex && enclavesIndex.length > 0 ? enclavesIndex[idx] : idx], enclaveUrl = _a.enclaveUrl, enclaveAddress = _a.enclaveAddress, operatorAddress = _a.operatorAddress, enclaveSlot = _a.enclaveSlot;
                                        http = new http_1.HttpClient((0, utils_1.ensureHttps)(enclaveUrl));
                                        endpoint = kind === "secret" ? exports.TEE_STORE_SECRET_NFT_ENDPOINT : exports.TEE_STORE_CAPSULE_NFT_ENDPOINT;
                                        post = function () { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, (0, exports.teePost)(http, endpoint, payload)];
                                                case 1: return [2 /*return*/, _a.sent()];
                                            }
                                        }); }); };
                                        return [4 /*yield*/, (0, utils_1.retryPost)(post, nbRetry)];
                                    case 1:
                                        retryFn = _b.sent();
                                        return [2 /*return*/, __assign({ enclaveAddress: enclaveAddress, operatorAddress: operatorAddress, enclaveSlot: enclaveSlot }, retryFn)];
                                }
                            });
                        }); }))];
                case 2:
                    teeRes = _a.sent();
                    return [2 /*return*/, teeRes.map(function (enclaveRes, i) {
                            var payload = payloads[i];
                            if ("isRetryError" in enclaveRes) {
                                var message = enclaveRes.message, status_3 = enclaveRes.status, enclaveAddress = enclaveRes.enclaveAddress, operatorAddress = enclaveRes.operatorAddress, enclaveSlot = enclaveRes.enclaveSlot;
                                return __assign({ enclaveAddress: enclaveAddress, operatorAddress: operatorAddress, enclaveSlot: enclaveSlot, description: message, nft_id: Number(payload.data.split("_")[0]), status: status_3, isError: true }, payload);
                            }
                            return __assign(__assign(__assign({}, enclaveRes), { isError: enclaveRes.status !== TEE_STORE_STATUS_SUCCESS }), payload);
                        })];
            }
        });
    });
};
exports.teeKeySharesStore = teeKeySharesStore;
/**
 * @name sharesAvailableOnTeeCluster
 * @summary           Check that all enclaves from a cluster have registered a the Capsule NFT or a Secret NFT's key shares
 * @param clusterId   The TEE Cluster id.
 * @param nftId       The Capsule NFT id or Secret NFT id to check key registration on enclaves.
 * @param kind        The kind of NFT linked to the key being checked: "secret" or "capsule"
 * @returns           A boolean status indicating if enclaves have stored the NFT shares.
 */
var sharesAvailableOnTeeCluster = function (clusterId, nftId, kind) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var teeEnclaves, isShareAvailable, i, exists;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (kind !== "secret" && kind !== "capsule") {
                        throw new Error("".concat(constants_1.Errors.TEE_ERROR, ": Kind must be either \"secret\" or \"capsule\""));
                    }
                    return [4 /*yield*/, (0, exports.getTeeEnclavesBaseUrl)(clusterId)];
                case 1:
                    teeEnclaves = _a.sent();
                    isShareAvailable = false;
                    i = 0;
                    _a.label = 2;
                case 2:
                    if (!(isShareAvailable !== true && i <= teeEnclaves.length - 1)) return [3 /*break*/, 4];
                    return [4 /*yield*/, (0, exports.getTeeEnclaveSharesAvailablility)(teeEnclaves[i], nftId, kind)];
                case 3:
                    exists = (_a.sent()).exists;
                    isShareAvailable = exists;
                    i += 1;
                    return [3 /*break*/, 2];
                case 4: return [2 /*return*/, isShareAvailable];
            }
        });
    });
};
exports.sharesAvailableOnTeeCluster = sharesAvailableOnTeeCluster;
/**
 * @name teeKeySharesRetrieve
 * @summary           Get secret data shares from TEE enclaves.
 * @param clusterId   The TEE Cluster id to upload shares to.
 * @param kind        The kind of nft linked to the key being retrieved: "secret" or "capsule"
 * @param payload     The payload containing secret NFT data, the keyring address and the signature. You can use our formatPayload() function.
 * @returns           TEE enclave response.
 */
var teeKeySharesRetrieve = function (clusterId, kind, payload) { return __awaiter(void 0, void 0, void 0, function () {
    var teeEnclaves, errors, shares;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (kind !== "secret" && kind !== "capsule") {
                    throw new Error("".concat(constants_1.Errors.TEE_RETRIEVE_ERROR, " : Kind must be either \"secret\" or \"capsule\""));
                }
                return [4 /*yield*/, (0, exports.getTeeEnclavesBaseUrl)(clusterId)];
            case 1:
                teeEnclaves = _a.sent();
                if (teeEnclaves.length !== exports.SSSA_NUMSHARES)
                    throw new Error("".concat(constants_1.Errors.NOT_CORRECT_AMOUNT_TEE_ENCLAVES, " - Got: ").concat(teeEnclaves.length, "; Expected: ").concat(exports.SSSA_NUMSHARES));
                errors = [];
                return [4 /*yield*/, Promise.all(teeEnclaves.map(function (baseUrl) { return __awaiter(void 0, void 0, void 0, function () {
                        var http, endpoint, res, _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    http = new http_1.HttpClient((0, utils_1.ensureHttps)(baseUrl));
                                    endpoint = kind === "secret" ? exports.TEE_RETRIEVE_SECRET_NFT_ENDPOINT : exports.TEE_RETRIEVE_CAPSULE_NFT_ENDPOINT;
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, (0, exports.teePost)(http, endpoint, payload)];
                                case 2:
                                    res = _b.sent();
                                    if (res.status !== TEE_RETRIEVE_STATUS_SUCCESS)
                                        errors.push(res.description ? res.description.split(":")[1] : "Share could not be retrieved");
                                    return [2 /*return*/, res.status === TEE_RETRIEVE_STATUS_SUCCESS && res.keyshare_data
                                            ? res.keyshare_data.split("_")[1]
                                            : undefined];
                                case 3:
                                    _a = _b.sent();
                                    errors.push("Enclave not available");
                                    return [3 /*break*/, 4];
                                case 4: return [2 /*return*/];
                            }
                        });
                    }); }))];
            case 2:
                shares = _a.sent();
                shares = shares.filter(function (x) { return x !== undefined; });
                if (shares.length < exports.SSSA_THRESHOLD) {
                    throw new Error("".concat(constants_1.Errors.TEE_RETRIEVE_ERROR, " - Shares could not be retrieved: ").concat(errors[0]));
                }
                return [2 /*return*/, shares];
        }
    });
}); };
exports.teeKeySharesRetrieve = teeKeySharesRetrieve;
/**
 * @name teeKeySharesRemove
 * @summary                 Remove the share of a burnt NFT from the enclaves.
 * @param clusterId         The TEE Cluster id to remove the shares of the burnt NFT.
 * @param kind              The kind of NFT linked to the key being deleted: "secret" or "capsule"
 * @param requesterAddress  The requester address who want to remove the NFT key share.
 * @param nftId             The burnt NFT id to remove the key.
 * @returns                 An array of JSONs containing the TEE enclave result (status (boolean), enclave_id, nft_id, description)
 */
var teeKeySharesRemove = function (clusterId, kind, requesterAddress, nftId) { return __awaiter(void 0, void 0, void 0, function () {
    var teeEnclaves, payload, shares;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (kind !== "secret" && kind !== "capsule") {
                    throw new Error("".concat(constants_1.Errors.TEE_REMOVE_ERROR, " : Kind must be either \"secret\" or \"capsule\""));
                }
                return [4 /*yield*/, (0, exports.getTeeEnclavesBaseUrl)(clusterId)];
            case 1:
                teeEnclaves = _a.sent();
                payload = {
                    requester_address: requesterAddress,
                    nft_id: nftId,
                };
                return [4 /*yield*/, Promise.all(teeEnclaves.map(function (baseUrl) { return __awaiter(void 0, void 0, void 0, function () {
                        var http, endpoint, res, _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    http = new http_1.HttpClient((0, utils_1.ensureHttps)(baseUrl));
                                    endpoint = kind === "secret" ? exports.TEE_REMOVE_SECRET_NFT_KEYSHARE_ENDPOINT : exports.TEE_REMOVE_CAPSULE_NFT_KEYSHARE_ENDPOINT;
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, (0, exports.teePost)(http, endpoint, payload)];
                                case 2:
                                    res = _b.sent();
                                    return [2 /*return*/, res];
                                case 3:
                                    _a = _b.sent();
                                    return [2 /*return*/, {
                                            status: constants_1.Errors.TEE_REMOVE_ERROR,
                                            nft_id: nftId,
                                            enclave_id: baseUrl,
                                            description: "Enclave not available",
                                        }];
                                case 4: return [2 /*return*/];
                            }
                        });
                    }); }))];
            case 2:
                shares = _a.sent();
                return [2 /*return*/, shares];
        }
    });
}); };
exports.teeKeySharesRemove = teeKeySharesRemove;
/**
 * @name formatReconciliationIntervalPayload
 * @summary                       Prepares post request payload to reconciliate the list of secret/capsule NFT synced on a block interval period.
 * @param interval                The block number interval period: an array of the starting and ending block.
 * @param metricsServerKeyring    The metric server keyring.
 * @returns                       A formatted payload ready to be submitted to TEE enclaves.
 */
var formatReconciliationIntervalPayload = function (interval, metricsServerKeyring) { return __awaiter(void 0, void 0, void 0, function () {
    var block_number, block_validation, formattedInterval, data_hash, authenticationToken, signedToken;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, crypto_2.getLastBlock)()];
            case 1:
                block_number = _a.sent();
                block_validation = exports.SIGNER_BLOCK_VALIDITY;
                formattedInterval = JSON.stringify(interval);
                data_hash = (0, crypto_1.createHash)("sha256").update(formattedInterval).digest("hex");
                authenticationToken = JSON.stringify({
                    block_number: block_number,
                    block_validation: block_validation,
                    data_hash: data_hash,
                });
                signedToken = (0, crypto_2.getSignatureFromKeyring)(metricsServerKeyring, authenticationToken);
                return [2 /*return*/, {
                        metric_account: metricsServerKeyring.address,
                        block_interval: formattedInterval,
                        auth_token: authenticationToken,
                        signature: signedToken,
                    }];
        }
    });
}); };
exports.formatReconciliationIntervalPayload = formatReconciliationIntervalPayload;
/**
 * @name teeNFTReconciliation
 * @summary                       Get a reconciliation list of secret/capsule NFT synced on a block interval period.
 * @param clusterId               The TEE Cluster id to query.
 * @param interval                The block number interval period: an array of the starting and ending block.
 * @param metricsServerKeyring    The metric server keyring.
 * @returns                       An array of JSONs containing the NFT list and the TEE addresses (operator & enclave)
 */
var teeNFTReconciliation = function (clusterId, interval, metricsServerKeyring) { return __awaiter(void 0, void 0, void 0, function () {
    var payload, teeEnclaves, errors, nftList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.formatReconciliationIntervalPayload)(interval, metricsServerKeyring)];
            case 1:
                payload = _a.sent();
                if (!payload)
                    throw new Error(constants_1.Errors.RECONCILIATION_PAYLOAD_UNDEFINED);
                return [4 /*yield*/, (0, exports.populateEnclavesData)(clusterId)];
            case 2:
                teeEnclaves = _a.sent();
                if (teeEnclaves.length !== exports.SSSA_NUMSHARES)
                    throw new Error("".concat(constants_1.Errors.NOT_CORRECT_AMOUNT_TEE_ENCLAVES, " - Got: ").concat(teeEnclaves.length, "; Expected: ").concat(exports.SSSA_NUMSHARES));
                errors = [];
                return [4 /*yield*/, Promise.all(teeEnclaves.map(function (e) { return __awaiter(void 0, void 0, void 0, function () {
                        var http, data, error_5, errorDescription;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    http = new http_1.HttpClient((0, utils_1.ensureHttps)(e.enclaveUrl));
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, (0, exports.teePost)(http, exports.RECONCILIATION_NFT_INTERVAL, payload)];
                                case 2:
                                    data = _a.sent();
                                    return [2 /*return*/, {
                                            enclaveAddress: e.enclaveAddress,
                                            operatorAddress: e.operatorAddress,
                                            nftId: data.nftid,
                                        }];
                                case 3:
                                    error_5 = _a.sent();
                                    errorDescription = error_5 instanceof Error ? error_5.message : JSON.stringify(error_5);
                                    errors.push({
                                        enclaveAddress: e.enclaveAddress,
                                        operatorAddress: e.operatorAddress,
                                        nftId: [],
                                        error: errorDescription,
                                    });
                                    return [3 /*break*/, 4];
                                case 4: return [2 /*return*/];
                            }
                        });
                    }); }))];
            case 3:
                nftList = _a.sent();
                if (!nftList)
                    throw new Error(constants_1.Errors.NFT_RECONCILIATION_FAILED);
                nftList = nftList.filter(function (x) { return x !== undefined; });
                return [2 /*return*/, __spreadArray(__spreadArray([], nftList, true), errors, true)];
        }
    });
}); };
exports.teeNFTReconciliation = teeNFTReconciliation;
