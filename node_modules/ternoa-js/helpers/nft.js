"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCapsuleNFTPrivateKey = exports.mintCapsuleNFT = exports.viewSecretNFT = exports.mintSecretNFT = exports.prepareAndStoreKeyShares = exports.getTemporarySignerKeys = exports.secretNftEncryptAndUploadFile = void 0;
var util_crypto_1 = require("@polkadot/util-crypto");
var encryption_1 = require("./encryption");
var tee_1 = require("./tee");
var crypto_1 = require("./crypto");
var account_1 = require("../account");
var constants_1 = require("../constants");
var nft_1 = require("../nft");
var blockchain_1 = require("../blockchain");
/**
 * @name secretNftEncryptAndUploadFile
 * @summary                 Encrypts and uploads a file on an IFPS gateway.
 * @param file              File to encrypt and then upload on IPFS.
 * @param publicPGPKey      Public Key to encrypt the file.
 * @param ipfsClient        A TernoaIPFS instance.
 * @param nftMetadata       Optional secret NFT metadata (Title, Description, (...)) {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-510-Secret-nft.md here}.
 * @param mediaMetadata     Optional asset NFT metadata (Name, Description, (...)) {@link https://github.com/capsule-corp-ternoa/ternoa-proposals/blob/main/TIPs/tip-510-Secret-nft.md here}.
 * @returns                 The data object with the secret NFT IPFS hash (ex: to add as offchain secret metadatas in the extrinsic).
 */
var secretNftEncryptAndUploadFile = function (file, publicPGPKey, ipfsClient, nftMetadata, mediaMetadata) { return __awaiter(void 0, void 0, void 0, function () {
    var encryptedFile, ipfsRes;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!file)
                    throw new Error("".concat(constants_1.Errors.IPFS_FILE_UPLOAD_ERROR, " - File undefined"));
                return [4 /*yield*/, (0, encryption_1.encryptFile)(file, publicPGPKey)];
            case 1:
                encryptedFile = _a.sent();
                return [4 /*yield*/, ipfsClient.storeSecretNFT(encryptedFile, file.type, publicPGPKey, nftMetadata, mediaMetadata)];
            case 2:
                ipfsRes = _a.sent();
                return [2 /*return*/, ipfsRes];
        }
    });
}); };
exports.secretNftEncryptAndUploadFile = secretNftEncryptAndUploadFile;
/**
 * @name getTemporarySignerKeys
 * @summary                 Generates a temporary signer account with soft-derivation
 * @param address           The owner address
 * @param lastBlockId       The last chain block number: Use our asyncronous getLastBlock() helper.
 * @returns                 A temporary signing key pair.
 */
var getTemporarySignerKeys = function (address, lastBlockId) { return __awaiter(void 0, void 0, void 0, function () {
    var tmpSignerMnemonic, tmpSignerPair;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                tmpSignerMnemonic = (0, util_crypto_1.mnemonicGenerate)();
                return [4 /*yield*/, (0, account_1.getKeyringFromSeed)(tmpSignerMnemonic, undefined, "".concat(lastBlockId, "_").concat(address))];
            case 1:
                tmpSignerPair = _a.sent();
                return [2 /*return*/, tmpSignerPair];
        }
    });
}); };
exports.getTemporarySignerKeys = getTemporarySignerKeys;
/**
 * @name prepareAndStoreKeyShares
 * @summary                  Splits the private key into shards, format and send them for upload on to a Tee Cluster.
 * @param privateKey         The private key to be splited with Shamir algorithm.
 * @param signer             Account owner of the private key to split (keyring) or address (string) .
 * @param nftId              The Capsule NFT id or Secret NFT id to link to the private key.
 * @param kind               The kind of nft linked to the key to upload: "secret" or "capsule".
 * @param extensionInjector  (Optional)The signer method retrived from your extension to sign the transaction. We recommand Polkadot extention: object must have a signer key.
 * @param clusterId          (Optional)The TEE Cluster id. Default is set to cluster id 0.
 * @returns                  The TEE enclave response (shards datas and description).
 */
var prepareAndStoreKeyShares = function (privateKey, signer, nftId, kind, extensionInjector, clusterId) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var lastBlockId, tmpSignerPair, shares, signerAddress, authMessage, authSignature, _a, _b, payloads;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (kind !== "secret" && kind !== "capsule") {
                        throw new Error("".concat(constants_1.Errors.TEE_UPLOAD_ERROR, " : Kind must be either \"secret\" or \"capsule\""));
                    }
                    if (typeof signer === "string" && !extensionInjector)
                        throw new Error("".concat(constants_1.Errors.TEE_UPLOAD_ERROR, " - INJECTOR_SIGNER_MISSING : injectorSigner must be provided when signer is of type string"));
                    if (typeof signer === "string" && !(0, blockchain_1.isValidAddress)(signer))
                        throw new Error("INVALID_ADDRESS_FORMAT");
                    return [4 /*yield*/, (0, crypto_1.getLastBlock)()];
                case 1:
                    lastBlockId = _c.sent();
                    return [4 /*yield*/, (0, exports.getTemporarySignerKeys)(typeof signer === "string" ? signer : signer.address, lastBlockId)
                        // 1. generate secret shares from the private key
                    ];
                case 2:
                    tmpSignerPair = _c.sent();
                    shares = (0, tee_1.generateKeyShares)(privateKey);
                    signerAddress = typeof signer === "string" ? signer : signer.address;
                    authMessage = "<Bytes>".concat(tmpSignerPair.address, "_").concat(lastBlockId, "_").concat(tee_1.SIGNER_BLOCK_VALIDITY, "</Bytes>");
                    if (!(typeof signer === "string")) return [3 /*break*/, 5];
                    _b = extensionInjector;
                    if (!_b) return [3 /*break*/, 4];
                    return [4 /*yield*/, (0, crypto_1.getSignatureFromExtension)(signer, extensionInjector, authMessage)];
                case 3:
                    _b = (_c.sent());
                    _c.label = 4;
                case 4:
                    _a = _b;
                    return [3 /*break*/, 6];
                case 5:
                    _a = (0, crypto_1.getSignatureFromKeyring)(signer, authMessage);
                    _c.label = 6;
                case 6:
                    authSignature = _a;
                    if (!authSignature)
                        throw new Error("".concat(constants_1.Errors.TEE_UPLOAD_ERROR, " : signing of the temporary authentication message failed when uploading payload"));
                    return [4 /*yield*/, Promise.all(shares.map(function (share) {
                            return (0, tee_1.formatStorePayload)(signerAddress, authMessage, authSignature, tmpSignerPair, nftId, share, lastBlockId);
                        }))
                        // 3. request to store a batch of secret shares to the enclave
                    ];
                case 7:
                    payloads = _c.sent();
                    return [4 /*yield*/, (0, tee_1.teeKeySharesStore)(clusterId, kind, payloads)];
                case 8: 
                // 3. request to store a batch of secret shares to the enclave
                return [2 /*return*/, _c.sent()];
            }
        });
    });
};
exports.prepareAndStoreKeyShares = prepareAndStoreKeyShares;
/**
 * @name mintSecretNFT
 * @summary                  Encrypts your data to create a secret NFT on-chain and uploads your key's shards on a TEE.
 * @param nftFile            File to upload as the preview of the encrypted NFT.
 * @param nftMetadata        NFT metadata (Title, Description).
 * @param secretNftFile      File to encrypt and then upload on IPFS.
 * @param secretNftMetadata  Secret NFT metadata (Title, Description).
 * @param ipfsClient         A TernoaIPFS instance.
 * @param ownerPair          Account of the secret NFT's owner.
 * @param clusterId          The TEE Cluster id. Default is set to cluster id 0.
 * @param royalty            Percentage of all second sales that the secret NFT creator will receive. Default is 0%. It's a decimal number in range [0, 100].
 * @param collectionId       The collection to which the secret NFT belongs. Optional Parameter: Default is undefined.
 * @param isSoulbound        If true, makes the secret NFT intransferable. Default is false.
 * @param waitUntil          Execution trigger that can be set either to BlockInclusion or BlockFinalization. Default is BlockInclusion.
 * @returns                  A JSON including both secretNftEvent & TEE enclave response (shards datas and description).
 */
var mintSecretNFT = function (nftFile, nftMetadata, secretNftFile, secretNftMetadata, ipfsClient, ownerPair, clusterId, royalty, collectionId, isSoulbound, waitUntil) {
    if (clusterId === void 0) { clusterId = 0; }
    if (royalty === void 0) { royalty = 0; }
    if (collectionId === void 0) { collectionId = undefined; }
    if (isSoulbound === void 0) { isSoulbound = false; }
    if (waitUntil === void 0) { waitUntil = constants_1.WaitUntil.BlockInclusion; }
    return __awaiter(void 0, void 0, void 0, function () {
        var _a, privateKey, publicKey, offchainDataHash, secretOffchainDataHash, secretNftEvent, teeRes;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: 
                // 0. query Enclave with /Health API
                return [4 /*yield*/, (0, tee_1.getEnclaveHealthStatus)(clusterId)
                    // 1. media encryption and upload
                ];
                case 1:
                    // 0. query Enclave with /Health API
                    _b.sent();
                    return [4 /*yield*/, (0, encryption_1.generatePGPKeys)()];
                case 2:
                    _a = _b.sent(), privateKey = _a.privateKey, publicKey = _a.publicKey;
                    return [4 /*yield*/, ipfsClient.storeNFT(nftFile, nftMetadata)];
                case 3:
                    offchainDataHash = (_b.sent()).Hash;
                    return [4 /*yield*/, (0, exports.secretNftEncryptAndUploadFile)(secretNftFile, publicKey, ipfsClient, secretNftMetadata)
                        // 2. secret NFT minting
                    ];
                case 4:
                    secretOffchainDataHash = (_b.sent()).Hash;
                    return [4 /*yield*/, (0, nft_1.createSecretNft)(offchainDataHash, secretOffchainDataHash, royalty, collectionId, isSoulbound, ownerPair, waitUntil)
                        // 3. request to format and store a batch of secret shares to the enclave
                    ];
                case 5:
                    secretNftEvent = _b.sent();
                    return [4 /*yield*/, (0, exports.prepareAndStoreKeyShares)(privateKey, ownerPair, secretNftEvent.nftId, "secret", undefined, clusterId)];
                case 6:
                    teeRes = _b.sent();
                    return [2 /*return*/, {
                            event: secretNftEvent,
                            clusterResponse: teeRes,
                        }];
            }
        });
    });
};
exports.mintSecretNFT = mintSecretNFT;
/**
 * @name viewSecretNFT
 * @summary                  Retrieves and decrypts the secret NFT hash.
 * @param nftId              The secret NFT id.
 * @param ipfsClient         A TernoaIPFS instance.
 * @param requester          Account of the secret NFT's owner(keyring) or address (string) or the decrypter account if NFT is delegated or rented.
 * @param requesterRole      Kind of the secret NFT's decrypter: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param extensionInjector  (Optional) The signer method retrived from your extension: object must have a signer key.
 * @param clusterId          (Optional)The TEE Cluster id. Default is set to cluster id 0.
 * @returns                  A string containing the secretNFT decrypted content.
 */
var viewSecretNFT = function (nftId, ipfsClient, requester, requesterRole, extensionInjector, clusterId) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var secretNftOffchainData, secretNftData, encryptedSecretOffchainData, lastBlockId, payload, shares, privatePGPKey, decryptedBase64;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: 
                // 0. query Enclave with /Health API
                return [4 /*yield*/, (0, tee_1.getEnclaveHealthStatus)(clusterId)
                    // 1. Get Secret NFT metadata hash
                ];
                case 1:
                    // 0. query Enclave with /Health API
                    _a.sent();
                    return [4 /*yield*/, (0, nft_1.getSecretNftOffchainData)(nftId)];
                case 2:
                    secretNftOffchainData = _a.sent();
                    return [4 /*yield*/, ipfsClient.getFile(secretNftOffchainData)];
                case 3:
                    secretNftData = (_a.sent());
                    return [4 /*yield*/, ipfsClient.getFile(secretNftData.properties.encrypted_media.hash)];
                case 4:
                    encryptedSecretOffchainData = (_a.sent());
                    return [4 /*yield*/, (0, crypto_1.getLastBlock)()];
                case 5:
                    lastBlockId = _a.sent();
                    return [4 /*yield*/, (0, tee_1.formatRetrievePayload)(requester, requesterRole, nftId, lastBlockId, tee_1.SIGNER_BLOCK_VALIDITY, extensionInjector)];
                case 6:
                    payload = _a.sent();
                    return [4 /*yield*/, (0, tee_1.teeKeySharesRetrieve)(clusterId, "secret", payload)
                        // 3. Combine shares
                    ];
                case 7:
                    shares = _a.sent();
                    privatePGPKey = (0, tee_1.combineKeyShares)(shares);
                    return [4 /*yield*/, (0, encryption_1.decryptFile)(encryptedSecretOffchainData, privatePGPKey)];
                case 8:
                    decryptedBase64 = _a.sent();
                    return [2 /*return*/, decryptedBase64];
            }
        });
    });
};
exports.viewSecretNFT = viewSecretNFT;
/**
 * @name mintCapsuleNFT
 * @summary                   Create a Capsule NFT and uploads your key's shards on a TEE.
 * @param owner               Account of the Capsule NFT's owner.
 * @param ipfsClient          A TernoaIPFS instance.
 * @param keys                Public and Private keys used to encrypt the file.
 * @param nftFile             File to upload as the preview of the Capsule NFT.
 * @param nftMetadata         The NFT preview metadata (Title, Description).
 * @param encryptedMedia      The array containing all the Capsule NFT encrypted media.
 * @param capsuleMetadata     (Optional) The Capusle NFT public metadata (Title, Description...).
 * @param clusterId           The TEE Cluster id. Default is 0
 * @param capsuleRoyalty      Percentage of all second sales that the capsule creator will receive. Default is 0%. It's a decimal number in range [0, 100].
 * @param capsuleCollectionId The collection to which the capsule NFT belongs. Optional Parameter: Default is undefined.
 * @param isSoulbound         If true, makes the Capsule intransferable. Default is false.
 * @param waitUntil           Execution trigger that can be set either to BlockInclusion or BlockFinalization. Default is BlockInclusion.
 * @returns                   A JSON including both capsuleEvent & TEE enclave response (shards datas and description).
 */
var mintCapsuleNFT = function (ownerPair, ipfsClient, keys, nftFile, nftMetadata, encryptedMedia, capsuleMetadata, clusterId, capsuleRoyalty, capsuleCollectionId, isSoulbound, waitUntil) {
    if (clusterId === void 0) { clusterId = 0; }
    if (capsuleRoyalty === void 0) { capsuleRoyalty = 0; }
    if (capsuleCollectionId === void 0) { capsuleCollectionId = undefined; }
    if (isSoulbound === void 0) { isSoulbound = false; }
    if (waitUntil === void 0) { waitUntil = constants_1.WaitUntil.BlockInclusion; }
    return __awaiter(void 0, void 0, void 0, function () {
        var offchainDataHash, capsuleOffchainDataHash, capsuleEvent, teeRes;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: 
                // 0. query Enclave with /Health API
                return [4 /*yield*/, (0, tee_1.getEnclaveHealthStatus)(clusterId)
                    // 1. media encryption and upload
                ];
                case 1:
                    // 0. query Enclave with /Health API
                    _a.sent();
                    return [4 /*yield*/, ipfsClient.storeNFT(nftFile, nftMetadata)];
                case 2:
                    offchainDataHash = (_a.sent()).Hash;
                    return [4 /*yield*/, ipfsClient.storeCapsuleNFT(keys.publicKey, encryptedMedia, capsuleMetadata)
                        // 2. capsule NFT minting
                    ];
                case 3:
                    capsuleOffchainDataHash = (_a.sent()).Hash;
                    return [4 /*yield*/, (0, nft_1.createCapsule)(offchainDataHash, capsuleOffchainDataHash, capsuleRoyalty, capsuleCollectionId, isSoulbound, ownerPair, waitUntil)
                        // 3. request to format and store a batch of secret shares to the enclave
                    ];
                case 4:
                    capsuleEvent = _a.sent();
                    return [4 /*yield*/, (0, exports.prepareAndStoreKeyShares)(keys.privateKey, ownerPair, capsuleEvent.nftId, "capsule", undefined, clusterId)];
                case 5:
                    teeRes = _a.sent();
                    return [2 /*return*/, {
                            event: capsuleEvent,
                            clusterResponse: teeRes,
                        }];
            }
        });
    });
};
exports.mintCapsuleNFT = mintCapsuleNFT;
/**
 * @name getCapsuleNFTPrivateKey
 * @summary                  Retrieves the capsule NFT private key to decrypt the secret hashes from properties.
 * @param nftId              The capsule NFT id.
 * @param requester          Account of the capsule NFT's owner (keyring) or address (string) or the decrypter account or address if NFT is delegated or rented.
 * @param requesterRole      Kind of the capsule NFT's decrypter: it can be either "OWNER", "DELEGATEE" or "RENTEE"
 * @param extensionInjector  (Optional) The signer method retrived from your extension: object must have a signer key.
 * @param clusterId          (Optional) The TEE Cluster id. Default is set to 0.
 * @returns                  A string containing the capsule NFT private key.
 */
var getCapsuleNFTPrivateKey = function (nftId, requester, requesterRole, extensionInjector, clusterId) {
    if (clusterId === void 0) { clusterId = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var lastBlockId, payload, shares;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: 
                // 0. query Enclave with /Health API
                return [4 /*yield*/, (0, tee_1.getEnclaveHealthStatus)(clusterId)
                    // 1. Format and retrieve payload
                ];
                case 1:
                    // 0. query Enclave with /Health API
                    _a.sent();
                    return [4 /*yield*/, (0, crypto_1.getLastBlock)()];
                case 2:
                    lastBlockId = _a.sent();
                    return [4 /*yield*/, (0, tee_1.formatRetrievePayload)(requester, requesterRole, nftId, lastBlockId, tee_1.SIGNER_BLOCK_VALIDITY, extensionInjector)];
                case 3:
                    payload = _a.sent();
                    return [4 /*yield*/, (0, tee_1.teeKeySharesRetrieve)(clusterId, "capsule", payload)
                        // 3. Combine Key
                    ];
                case 4:
                    shares = _a.sent();
                    // 3. Combine Key
                    return [2 /*return*/, (0, tee_1.combineKeyShares)(shares)];
            }
        });
    });
};
exports.getCapsuleNFTPrivateKey = getCapsuleNFTPrivateKey;
