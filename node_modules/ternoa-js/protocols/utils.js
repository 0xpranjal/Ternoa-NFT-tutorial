"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatProtocolCancellation = exports.formatOnConsentAtBlockProtocol = exports.formatOnConsentProtocol = exports.formatAtBlockWithResetProtocol = exports.formatAtBlockProtocol = void 0;
var enums_1 = require("./enums");
var blockchain_1 = require("../blockchain");
/**
 * @name formatAtBlockProtocol
 * @summary                        Returns an object according to the atBlock transmission protocol format.
 * @param protocol                 The protocol (string) : "atBlock".
 * @param executionBlock           The block number to execute the atBlock transmission protocol.
 * @returns                        An object representing the atBlock transmission protocol.
 */
var formatAtBlockProtocol = function (protocol, executionBlock) {
    var _a;
    if (protocol !== enums_1.ProtocolAction.AtBlock)
        throw new Error("INCORRECT_PROTOCOL: expected 'atBlock'.");
    if (typeof executionBlock !== "number")
        throw new Error("MUST_BE_A_NUMBER: executionBlock must be a number.");
    return _a = {}, _a[enums_1.ProtocolAction.AtBlock] = executionBlock, _a;
};
exports.formatAtBlockProtocol = formatAtBlockProtocol;
/**
 * @name formatAtBlockWithResetProtocol
 * @summary                        Returns an object according to the atBlockWithReset transmission protocol format.
 * @param protocol                 The protocol (string) : "BlockWithReset".
 * @param executionBlockWithReset  The block number to execute the atBlockWithReset transmission protocol. It can be updated later by user.
 * @returns                        An object representing the atBlockWithReset transmission protocol.
 */
var formatAtBlockWithResetProtocol = function (protocol, executionBlockWithReset) {
    var _a;
    if (protocol !== enums_1.ProtocolAction.AtBlockWithReset)
        throw new Error("INCORRECT_PROTOCOL: expected 'atBlockWithReset'.");
    if (typeof executionBlockWithReset !== "number")
        throw new Error("MUST_BE_A_NUMBER: executionBlockWithReset must be a number.");
    return _a = {}, _a[enums_1.ProtocolAction.AtBlockWithReset] = executionBlockWithReset, _a;
};
exports.formatAtBlockWithResetProtocol = formatAtBlockWithResetProtocol;
/**
 * @name formatOnConsentProtocol
 * @summary                        Returns an object according to the OnConsent transmission protocol format.
 * @param protocol                 The protocol (string) : "OnConsent".
 * @param consentList              An array of account address that need to consent the protocol.
 * @param threshold                The minimum number of consent to valid the protocol execution.
 * @returns                        An object representing the onConsent transmission protocol.
 */
var formatOnConsentProtocol = function (protocol, consentList, threshold) {
    var _a;
    if (protocol !== enums_1.ProtocolAction.OnConsent)
        throw new Error("INCORRECT_PROTOCOL: expected 'onConsent'.");
    consentList.map(function (address) {
        if (typeof address !== "string" && !(0, blockchain_1.isValidAddress)(address))
            throw new Error("MUST_BE_A_STRING: consentList must only contains only valid address.");
    });
    if (typeof threshold !== "number")
        throw new Error("MUST_BE_A_NUMBER: threshold must be a number.");
    return _a = {},
        _a[enums_1.ProtocolAction.OnConsent] = {
            consentList: consentList,
            threshold: threshold,
        },
        _a;
};
exports.formatOnConsentProtocol = formatOnConsentProtocol;
/**
 * @name formatOnConsentAtBlockProtocol
 * @summary                        Returns an object according to the onConsentAtBlock transmission protocol format.
 * @param protocol                 The protocol (string) : "onConsentAtBlock".
 * @param consentList              An array of account address that need to consent the protocol.
 * @param threshold                The minimum number of consent to valid the protocol execution.
 * @param block                    The block number before which each user consent is expected.
 * @returns                        An object representing the onConsentAtBlock transmission protocol.
 */
var formatOnConsentAtBlockProtocol = function (protocol, consentList, threshold, block) {
    var _a;
    if (protocol !== enums_1.ProtocolAction.OnConsentAtBlock)
        throw new Error("INCORRECT_PROTOCOL: expected 'onConsentAtBlock'.");
    consentList.map(function (address) {
        if (typeof address !== "string" && !(0, blockchain_1.isValidAddress)(address))
            throw new Error("MUST_BE_A_STRING: consentList must only contains only valid address.");
    });
    if (typeof threshold !== "number" && typeof block !== "number")
        throw new Error("MUST_BE_A_NUMBER: threshold and block must be numbers.");
    return _a = {},
        _a[enums_1.ProtocolAction.OnConsentAtBlock] = {
            consentList: consentList,
            threshold: threshold,
            block: block,
        },
        _a;
};
exports.formatOnConsentAtBlockProtocol = formatOnConsentAtBlockProtocol;
/**
 * @name formatProtocolCancellation
 * @summary                        Returns an object according to the cancellation kind required.
 * @param cancellation             The cancellation kind (string) : "anytime", "none" or "untilBlock".
 * @param UntilBlock               The block number before which user cancellation is available. Can only be set for "untilBlock" cancellation.
 * @returns                        An object representing the cancellation of the transmission protocol.
 */
var formatProtocolCancellation = function (cancellation, UntilBlock) {
    var _a, _b, _c;
    if (cancellation !== enums_1.TransmissionCancellationAction.Anytime &&
        cancellation !== enums_1.TransmissionCancellationAction.None &&
        cancellation !== enums_1.TransmissionCancellationAction.UntilBlock)
        throw new Error("INCORRECT_CANCELLATION: cancellation must be either 'anytime', 'none' or 'untilBlock'.");
    if (UntilBlock &&
        (cancellation == enums_1.TransmissionCancellationAction.None || cancellation == enums_1.TransmissionCancellationAction.Anytime))
        throw new Error("INCORRECT_CANCELLATION: untilBlock number can't be set for 'anytime' or 'none' cancellation.");
    if (cancellation == enums_1.TransmissionCancellationAction.UntilBlock && !UntilBlock)
        throw new Error("MISSING_DATA: untilBlock cancellation must have 'UntilBlock' param define as number.");
    if (UntilBlock && typeof UntilBlock !== "number")
        throw new Error("MUST_BE_A_NUMBER: UntilBlock must be a number.");
    return cancellation === enums_1.TransmissionCancellationAction.Anytime
        ? (_a = {}, _a[enums_1.TransmissionCancellationAction.Anytime] = null, _a) : cancellation === enums_1.TransmissionCancellationAction.UntilBlock && UntilBlock
        ? (_b = {}, _b[enums_1.TransmissionCancellationAction.UntilBlock] = UntilBlock, _b) : (_c = {}, _c[enums_1.TransmissionCancellationAction.None] = null, _c);
};
exports.formatProtocolCancellation = formatProtocolCancellation;
