"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.submitTxNonBlocking = exports.submitTxBlocking = exports.numberToBalance = exports.balanceToNumber = exports.isValidSignature = exports.isValidAddress = exports.forceBatchTxHex = exports.forceBatchTx = exports.batchAllTxHex = exports.batchAllTx = exports.batchTxHex = exports.batchTx = exports.submitTxHex = exports.signTxHex = exports.createTxHex = exports.createTx = exports.checkBatchAll = exports.checkForceBatch = exports.checkBatch = exports.checkTransactionSuccess = exports.checkFundsForTxFees = exports.getTxFees = exports.getTxAdditionalFee = exports.getTxInitialFee = exports.consts = exports.query = exports.safeDisconnect = exports.getApiEndpoint = exports.isApiConnected = exports.getRawApi = exports.initializeApi = void 0;
var bn_js_1 = __importDefault(require("bn.js"));
var util_crypto_1 = require("@polkadot/util-crypto");
var api_1 = require("@polkadot/api");
var keyring_1 = require("@polkadot/keyring");
var util_1 = require("@polkadot/util");
var balance_1 = require("../balance");
var constants_1 = require("../constants");
var events_1 = require("../events");
var marketplace_1 = require("../marketplace");
var nft_1 = require("../nft");
var utils_1 = require("./utils");
var DEFAULT_CHAIN_ENDPOINT = "wss://alphanet.ternoa.com";
var TERNOA_CHAIN_DECIMALS = 18;
var api;
var chainEndpoint = DEFAULT_CHAIN_ENDPOINT;
/**
 * @name initializeApi
 * @summary       Initialize substrate api with selected or default wss endpoint.
 * @description   The default chainEndpoint is "wss://alphanet.ternoa.com"
 */
var initializeApi = function (endpoint) { return __awaiter(void 0, void 0, void 0, function () {
    var wsProvider;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (endpoint)
                    chainEndpoint = endpoint;
                return [4 /*yield*/, (0, util_crypto_1.cryptoWaitReady)()];
            case 1:
                _a.sent();
                (0, exports.safeDisconnect)();
                wsProvider = new api_1.WsProvider(chainEndpoint);
                return [4 /*yield*/, api_1.ApiPromise.create({
                        provider: wsProvider,
                    })];
            case 2:
                api = _a.sent();
                return [2 /*return*/];
        }
    });
}); };
exports.initializeApi = initializeApi;
/**
 * @name getRawApi
 * @summary   Get initialized substrate Api instance.
 * @returns   Raw polkadot api instance, a wrapper around the RPC and interfaces of the chain.
 */
var getRawApi = function () {
    if (!api)
        throw new Error(constants_1.Errors.API_NOT_INITIALIZED);
    if (!api.isConnected)
        throw new Error(constants_1.Errors.API_NOT_CONNECTED);
    return api;
};
exports.getRawApi = getRawApi;
/**
 * @name isApiConnected
 * @summary   Check if the Api instance existed and if it is connected.
 * @returns   Boolean, true if the underlying provider is connected, false otherwise
 */
var isApiConnected = function () {
    return Boolean(api && api.isConnected);
};
exports.isApiConnected = isApiConnected;
/**
 * @name getApiEndpoint
 * @summary   Returns the wss api endpoint
 * @returns   String, the api endpoint connected with.
 */
var getApiEndpoint = function () {
    return chainEndpoint;
};
exports.getApiEndpoint = getApiEndpoint;
/**
 * @name safeDisconnect
 * @summary   Disconnect safely from the underlying provider, halting all network traffic
 */
var safeDisconnect = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(0, exports.isApiConnected)()) return [3 /*break*/, 2];
                return [4 /*yield*/, api.disconnect()];
            case 1:
                _a.sent();
                _a.label = 2;
            case 2: return [2 /*return*/];
        }
    });
}); };
exports.safeDisconnect = safeDisconnect;
/**
 * @name query
 * @summary   Generic function to make a chain query.
 * @example
 * <BR>
 *
 * ```javascript
 * // you can query without any args
 * const data = await query('balances', 'totalIssuance');
 *
 * // or you can pass args parameters to the storage query
 * const data = await query('system', 'account', ['5GesFQSwhmuMKAHcDrfm21Z5xrq6kW93C1ch2Xosq1rXx2Eh']);
 *
 * ```
 * @param module    The section required to make the chain query (eg. "system")
 * @param call      The call depending on the section (eg. "account")
 * @param args      Array of args for the call
 * @param callback  Callback function to enable subscription, if not given, no subscription will be made
 * @returns         Result of the query storage call
 */
var query = function (module, call, args, callback) {
    if (args === void 0) { args = []; }
    return __awaiter(void 0, void 0, void 0, function () {
        var api;
        var _a, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    api = (0, exports.getRawApi)();
                    if (!!callback) return [3 /*break*/, 2];
                    return [4 /*yield*/, (_a = api.query[module])[call].apply(_a, args)];
                case 1: return [2 /*return*/, _c.sent()];
                case 2: return [4 /*yield*/, (_b = api.query[module])[call].apply(_b, __spreadArray(__spreadArray([], args, false), [function (result) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, callback(result)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }], false))];
                case 3: return [2 /*return*/, _c.sent()];
            }
        });
    });
};
exports.query = query;
/**
 * @name consts
 * @summary   Generic function to get a chain constant.
 * @example
 * <BR>
 *
 * ```javascript
 * console.log(api.consts.balances.existentialDeposit.toString())
 * ```
 *
 * @param section The section required to get the chain constant (eg. "balances")
 * @param constantName The constantName depending on the section (eg. "existentialDeposit")
 * @returns The constant value
 */
var consts = function (section, constantName) {
    return (0, exports.getRawApi)().consts[section][constantName];
};
exports.consts = consts;
/**
 * @name getTxInitialFee
 * @summary         Get the weight fee estimation for a transaction.
 * @param txHex     Transaction hex
 * @param address   Public address of the sender
 * @returns         Transaction fee estimation
 */
var getTxInitialFee = function (txHex, address) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx, info;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                api = (0, exports.getRawApi)();
                tx = api.tx(txHex);
                return [4 /*yield*/, tx.paymentInfo(address)];
            case 1:
                info = _a.sent();
                return [2 /*return*/, info.partialFee];
        }
    });
}); };
exports.getTxInitialFee = getTxInitialFee;
/**
 * @name getTxAdditionalFee
 * @summary       Get the fee needed by Ternoa for specific transaction services.
 * @description   Some Ternoa's services required additional fees on top of chain gas fees, for example: minting a marketplace, minting an NFT or creating a capsule.
 * @param txHex   Transaction hex
 * @returns       Fee estimation
 */
var getTxAdditionalFee = function (txHex) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                api = (0, exports.getRawApi)();
                tx = api.tx(txHex);
                _a = "".concat(tx.method.section, "_").concat(tx.method.method);
                switch (_a) {
                    case "".concat(constants_1.txPallets.nft, "_").concat(constants_1.txActions.createNft): return [3 /*break*/, 1];
                    case "".concat(constants_1.txPallets.marketplace, "_").concat(constants_1.txActions.create): return [3 /*break*/, 3];
                }
                return [3 /*break*/, 5];
            case 1: return [4 /*yield*/, (0, nft_1.getNftMintFee)()];
            case 2: return [2 /*return*/, _b.sent()];
            case 3: return [4 /*yield*/, (0, marketplace_1.getMarketplaceMintFee)()];
            case 4: return [2 /*return*/, _b.sent()];
            case 5:
                {
                    return [2 /*return*/, new bn_js_1.default(0)];
                }
                _b.label = 6;
            case 6: return [2 /*return*/];
        }
    });
}); };
exports.getTxAdditionalFee = getTxAdditionalFee;
/**
 * @name getTxFees
 * @summary         Get the total fees for a transaction hex.
 * @param txHex     Hex of the transaction
 * @param address   Public address of the sender
 * @returns         Total estimated fee which is the sum of the chain initial fee and the optional additional fee
 */
var getTxFees = function (txHex, address) { return __awaiter(void 0, void 0, void 0, function () {
    var extrinsicFee, additionalFee;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getTxInitialFee)(txHex, address)];
            case 1:
                extrinsicFee = _a.sent();
                return [4 /*yield*/, (0, exports.getTxAdditionalFee)(txHex)];
            case 2:
                additionalFee = _a.sent();
                return [2 /*return*/, extrinsicFee.add(additionalFee)];
        }
    });
}); };
exports.getTxFees = getTxFees;
/**
 * @name checkFundsForTxFees
 * @summary   Check if a signed transaction sender has enough funds to pay transaction gas fees on transaction submit.
 * @param tx  Signed transaction object
 */
var checkFundsForTxFees = function (tx) { return __awaiter(void 0, void 0, void 0, function () {
    var balance, fees;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, balance_1.getTransferrableBalance)(tx.signer.toString())];
            case 1:
                balance = _a.sent();
                return [4 /*yield*/, (0, exports.getTxFees)(tx.toHex(), tx.signer.toString())];
            case 2:
                fees = _a.sent();
                if (balance.cmp(fees) === -1)
                    throw new Error(constants_1.Errors.INSUFFICIENT_FUNDS);
                return [2 /*return*/];
        }
    });
}); };
exports.checkFundsForTxFees = checkFundsForTxFees;
/**
 * @name checkTransactionSuccess
 * @summary       Check if a transaction is successful.
 * @param events  Result from a submitTxBlocking function: An events list.
 * @returns       Object containing a boolean success field indicating if transaction is successful
 *                and a the list of events in case of success or the Failed Event in case of transaction failure.
 */
var checkTransactionSuccess = function (events) {
    var failedEvent = events.findEvent(events_1.ExtrinsicFailedEvent);
    if (failedEvent) {
        return {
            isTxSuccess: false,
            failedEvent: failedEvent,
        };
    }
    return {
        isTxSuccess: true,
        events: events,
    };
};
exports.checkTransactionSuccess = checkTransactionSuccess;
/**
 * @name checkBatch
 * @summary                          Check if a classic batch of transactions is successful without being interrupted. For BatchAll or ForceBatch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a batch transaction: An events list.
 * @returns                          Object containing an isBatchInterrupted boolean, the succeeded or interrupted events and a isTxSuccess boolean to check the batch transaction status.
 */
var checkBatch = function (batchedTransactionsEvents) {
    var batchInterruptedEvent = batchedTransactionsEvents.findEvent(events_1.BatchInterruptedEvent);
    var checkTx = (0, exports.checkTransactionSuccess)(batchedTransactionsEvents);
    if (batchInterruptedEvent) {
        return {
            isBatchInterrupted: true,
            batchInterruptedEvent: batchInterruptedEvent,
            indexInterrupted: batchInterruptedEvent.index,
            isTxSuccess: true,
        };
    }
    return __assign(__assign({}, checkTx), { isBatchInterrupted: false });
};
exports.checkBatch = checkBatch;
/**
 * @name checkForceBatch
 * @summary                          Check if a forceBatch of transactions is completed without errors. For BatchAll or Batch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a forceBatch transaction: An events list.
 * @returns                          Object containing an isBatchCompleteWithoutErrors boolean, the succeeded or interrupted events and a isTxSuccess boolean to check the forceBatch transaction status.
 */
var checkForceBatch = function (batchedTransactionsEvents) {
    var batchIncompletedEvent = batchedTransactionsEvents.findEvent(events_1.BatchCompletedWithErrorsEvent);
    var checkTx = (0, exports.checkTransactionSuccess)(batchedTransactionsEvents);
    if (batchIncompletedEvent) {
        return {
            isBatchCompleteWithoutErrors: false,
            failedItems: batchedTransactionsEvents.findEvents(events_1.ItemFailedEvent),
            isTxSuccess: true,
        };
    }
    return __assign(__assign({}, checkTx), { isBatchCompleteWithoutErrors: true });
};
exports.checkForceBatch = checkForceBatch;
/**
 * @name checkBatchAll
 * @summary                          Check if a batchAll of transactions is succeeded or failed. For forceBatch or Batch tx, use the corresponding helper.
 * @param batchedTransactionsEvents  Result from a submitTxBlocking function triggered after a batchAll transaction: An events list.
 * @returns                          Object containing the succeeded or interrupted events and a isTxSuccess boolean to check the batchAll transaction status.
 */
var checkBatchAll = function (batchedTransactionsEvents) {
    return (0, exports.checkTransactionSuccess)(batchedTransactionsEvents);
};
exports.checkBatchAll = checkBatchAll;
/**
 * @name createTx
 * @summary             Create a transaction.
 * @param txPallet      Pallet module of the transaction
 * @param txExtrinsic   Subsequent extrinsic method of the transaction
 * @param txArgs        Arguments of the transaction
 * @returns             Transaction object unsigned
 */
var createTx = function (txPallet, txExtrinsic, txArgs) {
    if (txArgs === void 0) { txArgs = []; }
    return __awaiter(void 0, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            return [2 /*return*/, (_a = (0, exports.getRawApi)().tx[txPallet])[txExtrinsic].apply(_a, txArgs)];
        });
    });
};
exports.createTx = createTx;
/**
 * @name createTxHex
 * @summary             Create a transaction in hex format.
 * @param txPallet      Pallet module of the transaction
 * @param txExtrinsic   Subsequent extrinsic method of the transaction
 * @param txArgs        Arguments of the transaction
 * @returns             Hex value of the transaction
 */
var createTxHex = function (txPallet, txExtrinsic, txArgs) {
    if (txArgs === void 0) { txArgs = []; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.createTx)(txPallet, txExtrinsic, txArgs)];
                case 1:
                    tx = _a.sent();
                    return [2 /*return*/, tx.toHex()];
            }
        });
    });
};
exports.createTxHex = createTxHex;
/**
 * @name signTxHex
 * @summary         Sign a transaction.
 * @param keyring   Keyring pair to sign the data
 * @param txHex     Tx hex of the unsigned transaction to be signed
 * @param nonce     Nonce to be used in the transaction, default to next available
 * @param validity  Number of blocks during which transaction can be submitted, default to immortal
 * @returns         Hex value of the signed transaction
 */
var signTxHex = function (keyring, txHex, nonce, validity) {
    if (nonce === void 0) { nonce = -1; }
    if (validity === void 0) { validity = 0; }
    return __awaiter(void 0, void 0, void 0, function () {
        var txSigned;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.getRawApi)().tx(txHex).signAsync(keyring, { nonce: nonce, blockHash: api.genesisHash, era: validity })];
                case 1:
                    txSigned = _a.sent();
                    return [2 /*return*/, txSigned.toHex()];
            }
        });
    });
};
exports.signTxHex = signTxHex;
/**
 * @name submitTxHex
 * @summary         Send a signed transaction on the blockchain.
 * @param txHex     Transaction hex of the signed transaction to be submitted
 * @param callback  Callback function to enable subscription, if not given, no subscription will be made
 * @returns         Hash of the transaction
 */
var submitTxHex = function (txHex, callback) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx, unsub_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                api = (0, exports.getRawApi)();
                tx = api.tx(txHex);
                if (!(callback === undefined)) return [3 /*break*/, 2];
                return [4 /*yield*/, tx.send()];
            case 1:
                _a.sent();
                return [3 /*break*/, 4];
            case 2: return [4 /*yield*/, tx.send(function (result) { return __awaiter(void 0, void 0, void 0, function () {
                    var err_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, callback(result)];
                            case 1:
                                _a.sent();
                                if (result.status.isFinalized) {
                                    unsub_1();
                                }
                                return [3 /*break*/, 3];
                            case 2:
                                err_1 = _a.sent();
                                unsub_1();
                                throw err_1;
                            case 3: return [2 /*return*/];
                        }
                    });
                }); })];
            case 3:
                unsub_1 = _a.sent();
                _a.label = 4;
            case 4: return [2 /*return*/, tx.hash.toHex()];
        }
    });
}); };
exports.submitTxHex = submitTxHex;
/**
 * @name batchTx
 * @summary         Create a batch transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
var batchTx = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx;
    return __generator(this, function (_a) {
        api = (0, exports.getRawApi)();
        tx = (0, exports.createTx)(constants_1.txPallets.utility, constants_1.txActions.batch, [txHexes.map(function (x) { return api.tx(x); })]);
        return [2 /*return*/, tx];
    });
}); };
exports.batchTx = batchTx;
/**
 * @name batchTxHex
 * @summary         Create a batch transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
var batchTxHex = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.batchTx)(txHexes)];
            case 1:
                tx = _a.sent();
                return [2 /*return*/, tx.toHex()];
        }
    });
}); };
exports.batchTxHex = batchTxHex;
/**
 * @name batchAllTx
 * @summary         Create a batchAll transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
var batchAllTx = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx;
    return __generator(this, function (_a) {
        api = (0, exports.getRawApi)();
        tx = (0, exports.createTx)(constants_1.txPallets.utility, constants_1.txActions.batchAll, [txHexes.map(function (x) { return api.tx(x); })]);
        return [2 /*return*/, tx];
    });
}); };
exports.batchAllTx = batchAllTx;
/**
 * @name batchAllTxHex
 * @summary         Create a batchAll transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
var batchAllTxHex = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.batchAllTx)(txHexes)];
            case 1:
                tx = _a.sent();
                return [2 /*return*/, tx.toHex()];
        }
    });
}); };
exports.batchAllTxHex = batchAllTxHex;
/**
 * @name forceBatchTx
 * @summary         Create a forceBatch transaction of dispatch calls.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
var forceBatchTx = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var api, tx;
    return __generator(this, function (_a) {
        api = (0, exports.getRawApi)();
        tx = (0, exports.createTx)(constants_1.txPallets.utility, constants_1.txActions.forceBatch, [txHexes.map(function (x) { return api.tx(x); })]);
        return [2 /*return*/, tx];
    });
}); };
exports.forceBatchTx = forceBatchTx;
/**
 * @name forceBatchTxHex
 * @summary         Create a forceBatch transaction of dispatch calls in hex format.
 * @param txHexes   Transactions to execute in the batch call
 * @returns         Hex of the submittable extrinsic unsigned
 * @see             Learn more about Batch best practices {@link https://github.com/capsule-corp-ternoa/ternoa-js/wiki/5-Work-In-Progress-:-Cookbook#utility-batchbatchall here}.
 */
var forceBatchTxHex = function (txHexes) { return __awaiter(void 0, void 0, void 0, function () {
    var tx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.forceBatchTx)(txHexes)];
            case 1:
                tx = _a.sent();
                return [2 /*return*/, tx.toHex()];
        }
    });
}); };
exports.forceBatchTxHex = forceBatchTxHex;
/**
 * @name isValidAddress
 * @summary   Check if an address is a valid Ternoa address.
 * @param address
 * @returns   Boolean, true if the address is valid, false otherwise
 */
var isValidAddress = function (address) {
    try {
        (0, keyring_1.encodeAddress)((0, util_1.isHex)(address) ? (0, util_1.hexToU8a)(address) : (0, keyring_1.decodeAddress)(address));
        return true;
    }
    catch (error) {
        return false;
    }
};
exports.isValidAddress = isValidAddress;
/**
 * @name isValidSignature
 * @summary               Check if a message has been signed by the passed address.
 * @param signedMessage   Message to check.
 * @param signature
 * @param address         Address to verify the signer.
 * @returns               Boolean, true if the address signed the message, false otherwise
 */
var isValidSignature = function (signedMessage, signature, address) {
    var publicKey = (0, keyring_1.decodeAddress)(address);
    var hexPublicKey = (0, util_1.u8aToHex)(publicKey);
    return (0, util_crypto_1.signatureVerify)(signedMessage, signature, hexPublicKey).isValid;
};
exports.isValidSignature = isValidSignature;
/**
 * @name balanceToNumber
 * @summary         Format balance from BN to number.
 * @param input     BN input.
 * @param options   Formatting options from IFormatBalanceOptions.
 * @returns         Formatted balance with SI and unit notation.
 */
var balanceToNumber = function (input, options) {
    var _a;
    util_1.formatBalance.setDefaults({ decimals: 18, unit: (_a = options === null || options === void 0 ? void 0 : options.unit) !== null && _a !== void 0 ? _a : "CAPS" });
    return (0, util_1.formatBalance)(input, options);
};
exports.balanceToNumber = balanceToNumber;
/**
 * @name numberToBalance
 * @summary           Format balance from number to BN according to chain decimals.
 * @param _input      Number input
 * @param basePower   Number input
 * @returns           BN output
 */
var numberToBalance = function (_input, chainDecimals) {
    if (chainDecimals === void 0) { chainDecimals = TERNOA_CHAIN_DECIMALS; }
    if (typeof _input !== "number")
        throw new Error("".concat(constants_1.Errors.MUST_BE_A_NUMBER, " - Amount must be a number."));
    var input = String(_input);
    var siPower = new bn_js_1.default(chainDecimals);
    var basePower = chainDecimals;
    var siUnitPower = 0;
    var isDecimalValue = input.match(/^(\d+)\.(\d+)$/);
    var result;
    if (isDecimalValue) {
        if (siUnitPower - isDecimalValue[2].length < -basePower) {
            result = new bn_js_1.default(-1);
        }
        var div = new bn_js_1.default(input.replace(/\.\d*$/, ""));
        var modString = input.replace(/^\d+\./, "").substring(0, api.registry.chainDecimals[0] + 1);
        var mod = new bn_js_1.default(modString);
        result = div.mul(util_1.BN_TEN.pow(siPower)).add(mod.mul(util_1.BN_TEN.pow(new bn_js_1.default(basePower + siUnitPower - modString.length))));
    }
    else {
        result = new bn_js_1.default(input.replace(/[^\d]/g, "")).mul(util_1.BN_TEN.pow(siPower));
    }
    return result;
};
exports.numberToBalance = numberToBalance;
/**
 * @name submitTxBlocking
 * @summary             Signs and submits a transaction. It blocks the execution flow until the transaction is in a block or in a finalized block.
 * @param tx            Unsigned unsubmitted transaction Hash. The Hash is only valid for 5 minutes.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @param keyring       Account that will sign the transaction if provided
 * @returns             Returns a pair of objects :
 *                      - The first returned object contains some block information as the block hash, the block header and block extrinsics.
 *                      - The second returned object is an array of events which gets populated automatically once the operation is finished.
 *                      - The third returned argument is the submitted transaction hash.
 */
var submitTxBlocking = function (tx, waitUntil, keyring) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, conVar, events, blockInfo, txHash;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, (0, exports.submitTxNonBlocking)(tx, waitUntil, keyring)];
            case 1:
                _a = _b.sent(), conVar = _a[0], events = _a[1], blockInfo = _a[2], txHash = _a[3];
                return [4 /*yield*/, conVar.wait()];
            case 2:
                _b.sent();
                return [2 /*return*/, {
                        blockInfo: blockInfo,
                        events: events,
                        txHash: txHash,
                    }];
        }
    });
}); };
exports.submitTxBlocking = submitTxBlocking;
/**
 * @name submitTxNonBlocking
 * @summary             Signs and submits a transaction in a non-blocking way. Signing is optional.
 * @param tx            Unsigned unsubmitted transaction Hash. The Hash is only valid for 5 minutes.
 * @param waitUntil     Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @param keyring       Account that will sign the transaction if provided
 * @returns             Returns a group objects that are used to track the progress of the transaction execution:
 *                      - The first returned object is a conditional variable which can yield the information if the operation is finished.
 *                      - The second returned object is an array of events which gets populated automatically once the operation is finished.
 *                      - The third returned object contains the block information as the block hash, the block header and block extrinsics.
 *                      - The fouth returned argument is the submitted transaction hash.
 */
var submitTxNonBlocking = function (tx, waitUntil, keyring) { return __awaiter(void 0, void 0, void 0, function () {
    var conVar, chainEvents, blockInfo, callback, txHash;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                conVar = new utils_1.ConditionalVariable(500);
                chainEvents = new events_1.BlockchainEvents([]);
                blockInfo = new utils_1.BlockInfo();
                if (!keyring) return [3 /*break*/, 2];
                return [4 /*yield*/, (0, exports.signTxHex)(keyring, tx)];
            case 1:
                tx = _a.sent();
                _a.label = 2;
            case 2:
                callback = function (_a) {
                    var events = _a.events, status = _a.status;
                    return __awaiter(void 0, void 0, void 0, function () {
                        var isWaitingFinalization, isWaitingInclusion, blockHash, blockData;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    isWaitingFinalization = status.isFinalized && waitUntil == constants_1.WaitUntil.BlockFinalization;
                                    isWaitingInclusion = status.isInBlock && waitUntil == constants_1.WaitUntil.BlockInclusion;
                                    if (!(isWaitingInclusion || isWaitingFinalization)) return [3 /*break*/, 2];
                                    chainEvents.inner = events.map(function (eventRecord) { return events_1.BlockchainEvent.fromEvent(eventRecord.event); });
                                    blockHash = isWaitingFinalization ? status.asFinalized.toString() : status.asInBlock.toString();
                                    return [4 /*yield*/, api.rpc.chain.getBlock(blockHash)];
                                case 1:
                                    blockData = _b.sent();
                                    blockInfo.blockHash = blockHash;
                                    blockInfo.block = blockData.block;
                                    conVar.notify();
                                    _b.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    });
                };
                return [4 /*yield*/, (0, exports.submitTxHex)(tx, callback)];
            case 3:
                txHash = _a.sent();
                return [2 /*return*/, [conVar, chainEvents, blockInfo, txHash]];
        }
    });
}); };
exports.submitTxNonBlocking = submitTxNonBlocking;
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
