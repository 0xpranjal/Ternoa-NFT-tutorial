"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.acceptSubscriptionTerms = exports.acceptSubscriptionTermsTx = exports.changeSubscriptionTerms = exports.changeSubscriptionTermsTx = exports.acceptRentOffer = exports.acceptRentOfferTx = exports.retractRentOffer = exports.retractRentOfferTx = exports.makeRentOffer = exports.makeRentOfferTx = exports.rent = exports.rentTx = exports.revokeContract = exports.revokeContractTx = exports.cancelContract = exports.cancelContractTx = exports.createContract = exports.createContractTx = void 0;
var blockchain_1 = require("../blockchain");
var constants_1 = require("../constants");
var events_1 = require("../events");
var utils_1 = require("./utils");
/**
 * @name createContractTx
 * @summary                         Creates an unsigned unsubmitted Create-Rent-Contract Transaction Hash for an NFT.
 * @param nftId                     The NFT Id of the contract.
 * @param duration                  The contract duration : Fixed(EndBlock (a block number)) or Subscription(Period (a block number), MaxDuration (a block number), IsChangeable (a boolean))
 * @param acceptanceType            The type of acceptance: automatic or manual (with or without whitelist)
 * @param renterCanRevoke           A boolean to allow renter to cancel the contract once started
 * @param rentFee                   The fee to rent the contract: a token amount or an NFT
 * @param renterCancellationFee     The fee to cancel the contract (due by the renter): No Fee (None), FixedTokens amount, FlexibleTokens (only for Fixed contract) amount or an NFT
 * @param renteeCancellationFee     The fee to cancel the contract (due by the rentee): No Fee (None), FixedTokens amount, FlexibleTokens (only for Fixed contract) amount or an NFT
 * @returns                         Unsigned unsubmitted Create-Rent-Contract Transaction Hash. The Hash is only valid for 5 minutes.
 */
var createContractTx = function (nftId, duration, acceptanceType, renterCanRevoke, rentFee, renterCancellationFee, renteeCancellationFee) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, utils_1.validateTransformContractFee)(rentFee)];
            case 1:
                _a.sent();
                return [4 /*yield*/, (0, utils_1.validateTransformContractFee)(renterCancellationFee)];
            case 2:
                _a.sent();
                return [4 /*yield*/, (0, utils_1.validateTransformContractFee)(renteeCancellationFee)];
            case 3:
                _a.sent();
                return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.createContract, [
                        nftId,
                        duration,
                        acceptanceType,
                        renterCanRevoke,
                        rentFee,
                        renterCancellationFee,
                        renteeCancellationFee,
                    ])];
            case 4: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.createContractTx = createContractTx;
/**
 * @name createContract
 * @summary                         Creates a rental contract on the chain for an NFT.
 * @param nftId                     The NFT Id of the contract.
 * @param duration                  The contract duration : Fixed(EndBlock (a block number)) or Subscription(Period (a block number), MaxDuration (a block number), IsChangeable (a boolean))
 * @param acceptanceType            The type of acceptance: automatic or manual (with or without whitelist)
 * @param renterCanRevoke           A boolean to allow renter to cancel the contract once started
 * @param rentFee                   The fee to rent the contract: a token amount or an NFT
 * @param renterCancellationFee     The fee to cancel the contract (due by the renter): No Fee (None), FixedTokens amount, FlexibleTokens (only for Fixed contract) amount or an NFT
 * @param renteeCancellationFee     The fee to cancel the contract (due by the rentee): No Fee (None), FixedTokens amount, FlexibleTokens (only for Fixed contract) amount or an NFT
 * @param keyring                   Account that will sign the transaction.
 * @param waitUntil                 Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns                         ContractCreatedEvent Blockchain event.
 */
var createContract = function (nftId, duration, acceptanceType, renterCanRevoke, rentFee, renterCancellationFee, renteeCancellationFee, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, _a, blockInfo, events, creationBlockId, contractCreatedEvent;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, (0, exports.createContractTx)(nftId, duration, acceptanceType, renterCanRevoke, rentFee, renterCancellationFee, renteeCancellationFee)];
            case 1:
                tx = _c.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                _a = _c.sent(), blockInfo = _a.blockInfo, events = _a.events;
                creationBlockId = (_b = blockInfo.block) === null || _b === void 0 ? void 0 : _b.header.number.toNumber();
                contractCreatedEvent = events.findEventOrThrow(events_1.ContractCreatedEvent);
                if (creationBlockId) {
                    contractCreatedEvent.creationBlockId = creationBlockId;
                }
                return [2 /*return*/, contractCreatedEvent];
        }
    });
}); };
exports.createContract = createContract;
/**
 * @name cancelContractTx
 * @summary               Creates an unsigned unsubmitted Cancel-Rent-Contract Transaction Hash for an NFT.
 * @param nftId           The NFT Id of the contract to cancel.
 * @returns               Unsigned unsubmitted Cancel-Rent-Contract Transaction Hash. The Hash is only valid for 5 minutes.
 */
var cancelContractTx = function (nftId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.cancelContract, [nftId])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.cancelContractTx = cancelContractTx;
/**
 * @name cancelContract
 * @summary               Cancels a contract that is not running.
 * @param nftId           The NFT Id of the contract to cancel.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               ContractCanceledEvent Blockchain event.
 */
var cancelContract = function (nftId, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.cancelContractTx)(nftId)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.ContractCanceledEvent)];
        }
    });
}); };
exports.cancelContract = cancelContract;
/**
 * @name revokeContractTx
 * @summary               Creates an unsigned unsubmitted Revoke-Rent-Contract Transaction Hash for an NFT.
 * @param nftId           The NFT Id of the contract to revoke.
 * @returns               Unsigned unsubmitted Revoke-Rent-Contract Transaction Hash. The Hash is only valid for 5 minutes.
 */
var revokeContractTx = function (nftId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.revokeContract, [nftId])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.revokeContractTx = revokeContractTx;
/**
 * @name revokeContract
 * @summary               Revokes a running contract.
 * @param nftId           The NFT Id of the contract to revoke.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               ContractRevokedEvent Blockchain event.
 */
var revokeContract = function (nftId, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.revokeContractTx)(nftId)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.ContractRevokedEvent)];
        }
    });
}); };
exports.revokeContract = revokeContract;
/**
 * @name rentTx
 * @summary                       Creates an unsigned unsubmitted Rent-Contract Transaction Hash for an NFT.
 * @param nftId                   The NFT Id with the contract to rent.
 * @param contractCreationBlockId The contract creation block id to check to ensure contract authenticity.
 * @returns                       Unsigned unsubmitted Rent-Contract Transaction Hash. The Hash is only valid for 5 minutes.
 */
var rentTx = function (nftId, contractCreationBlockId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.rent, [nftId, contractCreationBlockId])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.rentTx = rentTx;
/**
 * @name rent
 * @summary                       Rents an nft.
 * @param nftId                   The NFT Id of the contract to rent.
 * @param contractCreationBlockId The contract creation block id to check to ensure contract authenticity.
 * @param keyring                 Account that will sign the transaction.
 * @param waitUntil               Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns                       ContractStartedEvent Blockchain event
 */
var rent = function (nftId, contractCreationBlockId, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.rentTx)(nftId, contractCreationBlockId)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.ContractStartedEvent)];
        }
    });
}); };
exports.rent = rent;
/**
 * @name makeRentOfferTx
 * @summary                       Creates an unsigned unsubmitted Make-Rent-Offer Transaction Hash for an NFT.
 * @param nftId                   The NFT Id of the contract to make the offer.
 * @param contractCreationBlockId The contract creation block id to check to ensure contract authenticity.
 * @returns                       Unsigned unsubmitted Make-Rent-Offer Transaction Hash. The Hash is only valid for 5 minutes.
 */
var makeRentOfferTx = function (nftId, contractCreationBlockId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.makeRentOffer, [nftId, contractCreationBlockId])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.makeRentOfferTx = makeRentOfferTx;
/**
 * @name makeRentOffer
 * @summary                       Makes an offer for an available contract.
 * @param nftId                   The NFT Id of the contract to make the offer.
 * @param contractCreationBlockId The contract creation block id to check to ensure contract authenticity.
 * @param keyring                 Account that will sign the transaction.
 * @param waitUntil               Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns                       ContractOfferCreated Blockchain event
 */
var makeRentOffer = function (nftId, contractCreationBlockId, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.makeRentOfferTx)(nftId, contractCreationBlockId)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.ContractOfferCreatedEvent)];
        }
    });
}); };
exports.makeRentOffer = makeRentOffer;
/**
 * @name retractRentOfferTx
 * @summary               Creates an unsigned unsubmitted Retract-Rent-Offer Transaction Hash for an NFT.
 * @param nftId           The NFT Id of the contract to retract the offer.
 * @returns               Unsigned unsubmitted Retract-Rent-Offer Transaction Hash. The Hash is only valid for 5 minutes.
 */
var retractRentOfferTx = function (nftId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.retractRentOffer, [nftId])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.retractRentOfferTx = retractRentOfferTx;
/**
 * @name retractRentOffer
 * @summary               Retracts a rent offer for manual acceptance contract.
 * @param nftId           The NFT Id of the contract to retract the offer.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               ContractOfferRetractedEvent Blockchain event
 */
var retractRentOffer = function (nftId, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.retractRentOfferTx)(nftId)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.ContractOfferRetractedEvent)];
        }
    });
}); };
exports.retractRentOffer = retractRentOffer;
/**
 * @name acceptRentOfferTx
 * @summary               Creates an unsigned unsubmitted Accept-Rent-Offer Transaction Hash for an NFT.
 * @param nftId           The NFT Id of the contract.
 * @param rentee          The adresse of the rentee who made the offer.
 * @returns               Unsigned unsubmitted Accept-Rent-Offer Transaction Hash. The Hash is only valid for 5 minutes.
 */
var acceptRentOfferTx = function (nftId, rentee) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.acceptRentOffer, [nftId, rentee])];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.acceptRentOfferTx = acceptRentOfferTx;
/**
 * @name acceptRentOffer
 * @summary               Accepts a rent offer for manual acceptance contract.
 * @param nftId           The NFT Id of the contract to retract the offer.
 * @param rentee          The adresse of the rentee who made the offer.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               ContractStartedEvent Blockchain event
 */
var acceptRentOffer = function (nftId, rentee, keyring, waitUntil) { return __awaiter(void 0, void 0, void 0, function () {
    var tx, events;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.acceptRentOfferTx)(nftId, rentee)];
            case 1:
                tx = _a.sent();
                return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
            case 2:
                events = (_a.sent()).events;
                return [2 /*return*/, events.findEventOrThrow(events_1.ContractStartedEvent)];
        }
    });
}); };
exports.acceptRentOffer = acceptRentOffer;
/**
 * @name changeSubscriptionTermsTx
 * @summary               Creates an unsigned unsubmitted Change-Contract-Subscription-Terms Transaction Hash for an NFT.
 * @param nftId           The NFT Id of the contract to change the subscription terms.
 * @param rentFee         The fee to rent the contract: a token amount
 * @param period          The period of subscription before renewal
 * @param maxDuration     The contract duration (in block). Optional, default is null.
 * @param isChangeable    A boolean to make the contract updatable.
 * @returns               Unsigned unsubmitted Change-Contract-Subscription-Terms Transaction Hash. The Hash is only valid for 5 minutes.
 */
var changeSubscriptionTermsTx = function (nftId, rentFee, period, maxDuration, isChangeable) {
    if (maxDuration === void 0) { maxDuration = null; }
    return __awaiter(void 0, void 0, void 0, function () {
        var formattedRentFee;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    formattedRentFee = typeof rentFee === "number" ? (0, blockchain_1.numberToBalance)(rentFee) : rentFee;
                    return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.changeSubscriptionTerms, [
                            nftId,
                            formattedRentFee,
                            period,
                            maxDuration,
                            isChangeable,
                        ])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
};
exports.changeSubscriptionTermsTx = changeSubscriptionTermsTx;
/**
 * @name changeSubscriptionTerms
 * @summary               Changes the subscription terms for subscription contracts.
 * @param nftId           The NFT Id of the contract to change the subscription terms.
 * @param rentFee         The fee to rent the contract: a token amount
 * @param period          The period of subscription before renewal
 * @param maxDuration     The contract duration (in block). Optional, default is null.
 * @param isChangeable    A boolean to make the contract updatable.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               ContractSubscriptionTermsChangedEvent Blockchain event
 */
var changeSubscriptionTerms = function (nftId, rentFee, period, maxDuration, isChangeable, keyring, waitUntil) {
    if (maxDuration === void 0) { maxDuration = null; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx, events;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.changeSubscriptionTermsTx)(nftId, rentFee, period, maxDuration, isChangeable)];
                case 1:
                    tx = _a.sent();
                    return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
                case 2:
                    events = (_a.sent()).events;
                    return [2 /*return*/, events.findEventOrThrow(events_1.ContractSubscriptionTermsChangedEvent)];
            }
        });
    });
};
exports.changeSubscriptionTerms = changeSubscriptionTerms;
/**
 * @name acceptSubscriptionTermsTx
 * @summary               Creates an unsigned unsubmitted Accept-Contract-Subscription-Terms Transaction Hash for an NFT.
 * @param nftId           The NFT Id of the contract to accept the new subscription terms.
 * @param rentFee         The fee to rent the contract: a token amount
 * @param period          The period of subscription before renewal
 * @param maxDuration     The contract duration (in block). Optional, default is null.
 * @param isChangeable    A boolean to make the contract updatable.
 * @returns               Unsigned unsubmitted Accept-Contract-Subscription-Terms Transaction Hash. The Hash is only valid for 5 minutes.
 */
var acceptSubscriptionTermsTx = function (nftId, rentFee, period, maxDuration, isChangeable) {
    if (maxDuration === void 0) { maxDuration = null; }
    return __awaiter(void 0, void 0, void 0, function () {
        var formattedRentFee;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    formattedRentFee = typeof rentFee === "number" ? (0, blockchain_1.numberToBalance)(rentFee) : rentFee;
                    return [4 /*yield*/, (0, blockchain_1.createTxHex)(constants_1.txPallets.rent, constants_1.txActions.acceptSubscriptionTerms, [
                            nftId,
                            formattedRentFee,
                            period,
                            maxDuration,
                            isChangeable,
                        ])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
};
exports.acceptSubscriptionTermsTx = acceptSubscriptionTermsTx;
/**
 * @name acceptSubscriptionTerms
 * @summary               Accepts the subscription terms for subscription contracts.
 * @param nftId           The NFT Id of the contract to change the subscription terms.
 * @param rentFee         The fee to rent the contract: a token amount
 * @param period          The period of subscription before renewal
 * @param maxDuration     The contract duration (in block). Optional, default is null.
 * @param isChangeable    A boolean to make the contract updatable.
 * @param keyring         Account that will sign the transaction.
 * @param waitUntil       Execution trigger that can be set either to BlockInclusion or BlockFinalization.
 * @returns               ContractSubscriptionTermsAcceptedEvent Blockchain event
 */
var acceptSubscriptionTerms = function (nftId, rentFee, period, maxDuration, isChangeable, keyring, waitUntil) {
    if (maxDuration === void 0) { maxDuration = null; }
    return __awaiter(void 0, void 0, void 0, function () {
        var tx, events;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, exports.acceptSubscriptionTermsTx)(nftId, rentFee, period, maxDuration, isChangeable)];
                case 1:
                    tx = _a.sent();
                    return [4 /*yield*/, (0, blockchain_1.submitTxBlocking)(tx, waitUntil, keyring)];
                case 2:
                    events = (_a.sent()).events;
                    return [2 /*return*/, events.findEventOrThrow(events_1.ContractSubscriptionTermsAcceptedEvent)];
            }
        });
    });
};
exports.acceptSubscriptionTerms = acceptSubscriptionTerms;
