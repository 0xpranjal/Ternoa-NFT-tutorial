"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTransformContractFee = exports.formatCancellationFee = exports.formatRentFee = exports.formatAcceptanceType = exports.formatDuration = void 0;
var blockchain_1 = require("../blockchain");
var constants_1 = require("../constants");
var enum_1 = require("./enum");
/**
 * @name formatDuration
 * @summary Returns an object representing a duration in either fixed or subscription format.
 *
 * @param type - The type of duration. Can be either 'fixed' or 'subscription'.
 * @param duration - The length of the contract duration in blocks.
 * @param maxDuration - (Optional) The maximum length of the contract subscription duration in blocks. Only applicable for subscriptions.
 * @param isChangeable - (Optional) A boolean indicating if the duration can be changed. Only applicable for subscriptions.
 *
 * @returns An object representing the duration of a contract.
 */
var formatDuration = function (type, duration, maxDuration, isChangeable) {
    var _a, _b, _c;
    if (isChangeable === void 0) { isChangeable = false; }
    if (type !== "fixed" && type !== "subscription")
        throw new Error("INCORRECT_TYPE: type has to be either 'fixed' or 'subscription'.");
    if (typeof duration !== "number")
        throw new Error("MUST_BE_A_NUMBER: duration must be a number.");
    return type === "fixed"
        ? (_a = {},
            _a[enum_1.DurationAction.Fixed] = duration,
            _a) : (_b = {},
        _b[enum_1.DurationAction.Subscription] = (_c = {},
            _c[enum_1.SubscriptionActionDetails.PeriodLength] = duration,
            _c[enum_1.SubscriptionActionDetails.MaxDuration] = maxDuration !== null && maxDuration !== void 0 ? maxDuration : null,
            _c[enum_1.SubscriptionActionDetails.IsChangeable] = isChangeable,
            _c),
        _b);
};
exports.formatDuration = formatDuration;
/**
 * @name formatAcceptanceType
 * @summary Returns an object representing an acceptance type in either auto or manual format.
 *
 * @param type - The type of acceptance. Can be either 'auto' or 'manual'.
 * @param list - (Optional) A list of addresses. Only applicable for auto acceptance.
 *
 * @returns An object representing the acceptance type of a contract.
 */
var formatAcceptanceType = function (type, list) {
    var _a, _b;
    if (type !== "auto" && type !== "manual")
        throw new Error("INCORRECT_TYPE: type has to be either 'auto' or 'manual'.");
    return type === "auto"
        ? (_a = {},
            _a[enum_1.AcceptanceAction.AutoAcceptance] = list !== null && list !== void 0 ? list : null,
            _a) : (_b = {},
        _b[enum_1.AcceptanceAction.ManualAcceptance] = list !== null && list !== void 0 ? list : null,
        _b);
};
exports.formatAcceptanceType = formatAcceptanceType;
/**
 * @name formatRentFee
 * @summary Returns an object representing a rent fee in either tokens or NFT format.
 *
 * @param type - The type of rent fee. Can be either 'tokens' or 'nft'.
 * @param value - The value of the rent fee. If type is 'tokens' value refers to a balance amount. If type is 'nft' value refers to the NFT id.
 *
 * @returns An object representing the rent fee of a contract.
 */
var formatRentFee = function (type, value) {
    var _a, _b;
    if (type !== "tokens" && type !== "nft")
        throw new Error("INCORRECT_TYPE: type has to be either 'tokens' or 'nft'.");
    if (typeof value !== "number")
        throw new Error("MUST_BE_A_NUMBER: value must be a number.");
    return type === "tokens"
        ? (_a = {},
            _a[enum_1.RentFeeAction.Tokens] = value,
            _a) : (_b = {},
        _b[enum_1.RentFeeAction.NFT] = value,
        _b);
};
exports.formatRentFee = formatRentFee;
/**
 * @name formatCancellationFee
 * @summary Returns an object representing a cancellation fee in either fixed, flexible or NFT format.
 *
  type: "fixed" | "flexible" | "nft" | "none",
 * @param type - The type of cancellation fee. Can be either 'fixed', 'flexible', 'nft' or 'none'.
 * @param value - The value of the rent fee. If type is 'fixed' or 'flexible' value refers to a balance amount. If type is 'nft' value refers to the NFT id.
 *
 * @returns An object representing the rent fee of a contract.
 */
var formatCancellationFee = function (type, value) {
    var _a, _b, _c;
    if (type !== "fixed" && type !== "flexible" && type !== "nft" && type !== "none")
        throw new Error("INCORRECT_TYPE: type has to be either 'fixed', 'flexible', 'nft' or 'none'.");
    if (type === "none")
        return enum_1.CancellationFeeAction.None;
    if (value === undefined)
        throw new Error("".concat(constants_1.Errors.VALUE_MUST_BE_DEFINED));
    switch (type) {
        case "fixed":
            return _a = {},
                _a[enum_1.CancellationFeeAction.FixedTokens] = value,
                _a;
        case "flexible":
            return _b = {},
                _b[enum_1.CancellationFeeAction.FlexibleTokens] = value,
                _b;
        case "nft":
            return _c = {},
                _c[enum_1.CancellationFeeAction.NFT] = value,
                _c;
        default:
            return enum_1.CancellationFeeAction.None;
    }
};
exports.formatCancellationFee = formatCancellationFee;
/**
 * @name validateTransformContractFee
 * @summary         Validates the type fee and format it accordingly. Numbers are formatted into BN.
 * @param fee       The fee to format : It can only be a RentFeeType or CancellationFeeType.
 * @returns         The formatted fee.
 */
var validateTransformContractFee = function (fee) {
    if (typeof fee === "object") {
        if ("tokens" in fee && typeof fee.tokens === "number") {
            var tokensFee = (0, blockchain_1.numberToBalance)(fee.tokens);
            fee.tokens = tokensFee;
        }
        if ("fixedTokens" in fee && typeof fee.fixedTokens === "number") {
            var tokensFee = (0, blockchain_1.numberToBalance)(fee.fixedTokens);
            fee.fixedTokens = tokensFee;
        }
        if ("flexibleTokens" in fee && typeof fee.flexibleTokens === "number") {
            var tokensFee = (0, blockchain_1.numberToBalance)(fee.flexibleTokens);
            fee.flexibleTokens = tokensFee;
        }
    }
    return fee;
};
exports.validateTransformContractFee = validateTransformContractFee;
