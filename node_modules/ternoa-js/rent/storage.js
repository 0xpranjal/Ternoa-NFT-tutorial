"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRentingQueues = exports.getRentalOffers = exports.getRentalContractData = void 0;
var util_1 = require("@polkadot/util");
var blockchain_1 = require("../blockchain");
var constants_1 = require("../constants");
var enum_1 = require("./enum");
var utils_1 = require("../helpers/utils");
/**
 * @name getRentalContractData
 * @summary         Provides the data related to a rent contract.
 * @param nftId     The ID of the contracted NFT.
 * @returns         A JSON object with the rental contract data.
 */
var getRentalContractData = function (nftId) { return __awaiter(void 0, void 0, void 0, function () {
    var data, _a, creationBlock, startBlock, renter, rentee, duration, acceptanceType, renterCanRevoke, rentFee, renterCancellationFee, renteeCancellationFee, creationBlockDate, startBlockDate, _b, isManualAcceptance, acceptance, acceptanceList, isRentFeeToken, rentFeeType, rentFeeValue, rentFeeValueRounded, renterCancellationFeeType, renterCancellationFeeValue, renterCancellationFeeValueRounded, renteeCancellationFeeType, renteeCancellationFeeValue, renteeCancellationFeeValueRounded, error_1;
    var _c, _d;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.query)(constants_1.txPallets.rent, constants_1.chainQuery.contracts, [nftId])];
            case 1:
                data = _e.sent();
                if (data.isEmpty) {
                    return [2 /*return*/, null];
                }
                _e.label = 2;
            case 2:
                _e.trys.push([2, 7, , 8]);
                _a = data.toJSON(), creationBlock = _a.creationBlock, startBlock = _a.startBlock, renter = _a.renter, rentee = _a.rentee, duration = _a.duration, acceptanceType = _a.acceptanceType, renterCanRevoke = _a.renterCanRevoke, rentFee = _a.rentFee, renterCancellationFee = _a.renterCancellationFee, renteeCancellationFee = _a.renteeCancellationFee;
                return [4 /*yield*/, (0, blockchain_1.blockNumberToDate)(creationBlock)];
            case 3:
                creationBlockDate = _e.sent();
                if (!(startBlock !== null)) return [3 /*break*/, 5];
                return [4 /*yield*/, (0, blockchain_1.blockNumberToDate)(startBlock)];
            case 4:
                _b = _e.sent();
                return [3 /*break*/, 6];
            case 5:
                _b = null;
                _e.label = 6;
            case 6:
                startBlockDate = _b;
                isManualAcceptance = enum_1.AcceptanceAction.ManualAcceptance in acceptanceType;
                acceptance = isManualAcceptance ? enum_1.AcceptanceAction.ManualAcceptance : enum_1.AcceptanceAction.AutoAcceptance;
                acceptanceList = (_d = (_c = acceptanceType.manualAcceptance) !== null && _c !== void 0 ? _c : acceptanceType.autoAcceptance) !== null && _d !== void 0 ? _d : [];
                isRentFeeToken = enum_1.RentFeeAction.Tokens in rentFee;
                rentFeeType = isRentFeeToken ? enum_1.RentFeeAction.Tokens : enum_1.RentFeeAction.NFT;
                rentFeeValue = isRentFeeToken ? (0, util_1.bnToBn)(rentFee.tokens).toString() : Number(rentFee.nft);
                rentFeeValueRounded = typeof rentFeeValue === "number" ? rentFeeValue : (0, utils_1.roundBalance)(rentFeeValue);
                renterCancellationFeeType = void 0, renterCancellationFeeValue = void 0, renterCancellationFeeValueRounded = void 0;
                switch (true) {
                    case enum_1.CancellationFeeAction.FixedTokens in renterCancellationFee:
                        renterCancellationFeeType = enum_1.CancellationFeeAction.FixedTokens;
                        renterCancellationFeeValue = (0, util_1.bnToBn)(renterCancellationFee[renterCancellationFeeType]).toString();
                        renterCancellationFeeValueRounded = (0, utils_1.roundBalance)(renterCancellationFeeValue);
                        break;
                    case enum_1.CancellationFeeAction.FlexibleTokens in renterCancellationFee:
                        renterCancellationFeeType = enum_1.CancellationFeeAction.FlexibleTokens;
                        renterCancellationFeeValue = (0, util_1.bnToBn)(renterCancellationFee[renterCancellationFeeType]).toString();
                        renterCancellationFeeValueRounded = (0, utils_1.roundBalance)(renterCancellationFeeValue);
                        break;
                    case enum_1.CancellationFeeAction.NFT in renterCancellationFee:
                        renterCancellationFeeType = enum_1.CancellationFeeAction.NFT;
                        renterCancellationFeeValue = Number(renterCancellationFee[renterCancellationFeeType]);
                        renterCancellationFeeValueRounded = renterCancellationFeeValue;
                        break;
                    default:
                        renterCancellationFeeType = enum_1.CancellationFeeAction.None;
                        renterCancellationFeeValue = null;
                        renterCancellationFeeValueRounded = null;
                        break;
                }
                renteeCancellationFeeType = void 0, renteeCancellationFeeValue = void 0, renteeCancellationFeeValueRounded = void 0;
                switch (true) {
                    case enum_1.CancellationFeeAction.FixedTokens in renteeCancellationFee:
                        renteeCancellationFeeType = enum_1.CancellationFeeAction.FixedTokens;
                        renteeCancellationFeeValue = (0, util_1.bnToBn)(renteeCancellationFee[renteeCancellationFeeType]).toString();
                        renteeCancellationFeeValueRounded = (0, utils_1.roundBalance)(renteeCancellationFeeValue);
                        break;
                    case enum_1.CancellationFeeAction.FlexibleTokens in renteeCancellationFee:
                        renteeCancellationFeeType = enum_1.CancellationFeeAction.FlexibleTokens;
                        renteeCancellationFeeValue = (0, util_1.bnToBn)(renteeCancellationFee[renteeCancellationFeeType]).toString();
                        renteeCancellationFeeValueRounded = (0, utils_1.roundBalance)(renteeCancellationFeeValue);
                        break;
                    case enum_1.CancellationFeeAction.NFT in renteeCancellationFee:
                        renteeCancellationFeeType = enum_1.CancellationFeeAction.NFT;
                        renteeCancellationFeeValue = Number(renteeCancellationFee[renteeCancellationFeeType]);
                        renteeCancellationFeeValueRounded = renteeCancellationFeeValue;
                        break;
                    default:
                        renteeCancellationFeeType = enum_1.CancellationFeeAction.None;
                        renteeCancellationFeeValue = null;
                        renteeCancellationFeeValueRounded = null;
                        break;
                }
                return [2 /*return*/, {
                        creationBlock: creationBlock,
                        creationBlockDate: creationBlockDate,
                        startBlock: startBlock,
                        startBlockDate: startBlockDate,
                        renter: renter,
                        rentee: rentee,
                        duration: duration,
                        acceptanceType: acceptance,
                        acceptanceList: acceptanceList,
                        renterCanRevoke: renterCanRevoke,
                        rentFeeType: rentFeeType,
                        rentFee: rentFeeValue,
                        rentFeeRounded: rentFeeValueRounded,
                        renterCancellationFeeType: renterCancellationFeeType,
                        renterCancellationFee: renterCancellationFeeValue,
                        renterCancellationFeeRounded: renterCancellationFeeValueRounded,
                        renteeCancellationFeeType: renteeCancellationFeeType,
                        renteeCancellationFee: renteeCancellationFeeValue,
                        renteeCancellationFeeRounded: renteeCancellationFeeValueRounded,
                    }];
            case 7:
                error_1 = _e.sent();
                throw new Error("".concat(constants_1.Errors.RENT_NFT_CONVERSION_ERROR));
            case 8: return [2 /*return*/];
        }
    });
}); };
exports.getRentalContractData = getRentalContractData;
/**
 * @name getRentalOffers
 * @summary       Provides the data related to rent contracts offers.
 * @param nftId   The ID of the contracted NFT.
 * @returns       An Array of adresse(s) (string) or null if no offer are available.
 */
var getRentalOffers = function (nftId) { return __awaiter(void 0, void 0, void 0, function () {
    var data, result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.query)(constants_1.txPallets.rent, constants_1.chainQuery.offers, [nftId])];
            case 1:
                data = _a.sent();
                result = data.toJSON();
                return [2 /*return*/, result];
        }
    });
}); };
exports.getRentalOffers = getRentalOffers;
/**
 * @name getRentingQueues
 * @summary       Provides the deadlines related to contracts in queues for available contracts, running fixed contract and running subscribed contract.
 * @returns       An object containing an array with NFT ID, the block expriation ID for each fixedQueue, subscriptionQueue or availableQueue. See the RentingQueuesType type.
 */
var getRentingQueues = function () { return __awaiter(void 0, void 0, void 0, function () {
    var data, _a, fixedQueue, subscriptionQueue, availableQueue;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, (0, blockchain_1.query)(constants_1.txPallets.rent, constants_1.chainQuery.queues)];
            case 1:
                data = _b.sent();
                try {
                    _a = data.toJSON(), fixedQueue = _a.fixedQueue, subscriptionQueue = _a.subscriptionQueue, availableQueue = _a.availableQueue;
                    return [2 /*return*/, {
                            fixedQueue: fixedQueue.map(function (queue) { return ({
                                nftId: queue[0],
                                endingBlockId: queue[1],
                            }); }),
                            subscriptionQueue: subscriptionQueue.map(function (queue) { return ({
                                nftId: queue[0],
                                renewalOrEndBlockId: queue[1],
                            }); }),
                            availableQueue: availableQueue.map(function (queue) { return ({
                                nftId: queue[0],
                                expirationBlockId: queue[1],
                            }); }),
                        }];
                }
                catch (error) {
                    throw new Error("".concat(constants_1.Errors.RENT_NFT_CONVERSION_ERROR));
                }
                return [2 /*return*/];
        }
    });
}); };
exports.getRentingQueues = getRentingQueues;
